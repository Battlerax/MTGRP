{"version":3,"sources":["webpack:///webpack/bootstrap b0ba8199125b1109305c","webpack:///external \"inversify\"","webpack:///external \"tslib\"","webpack:///./src/container/ServiceIdentifiers.ts","webpack:///./src/node/NodeUtils.ts","webpack:///./src/utils/RandomGeneratorUtils.ts","webpack:///./src/decorators/Initializable.ts","webpack:///./src/node/Node.ts","webpack:///./src/custom-nodes/AbstractCustomNode.ts","webpack:///./src/utils/Utils.ts","webpack:///./src/enums/container/CustomNodes.ts","webpack:///./src/node-transformers/AbstractNodeTransformer.ts","webpack:///external \"estraverse\"","webpack:///external \"string-template\"","webpack:///./src/enums/NodeType.ts","webpack:///./src/node/Nodes.ts","webpack:///./src/enums/ObfuscationEvents.ts","webpack:///./src/enums/container/ObfuscationReplacers.ts","webpack:///./src/JavaScriptObfuscator.ts","webpack:///./src/node/NodeAppender.ts","webpack:///./src/custom-nodes/AbstractCustomNodeGroup.ts","webpack:///external \"escodegen-wallaby\"","webpack:///./src/enums/SourceMapMode.ts","webpack:///./src/node-transformers/obfuscating-transformers/replacers/AbstractReplacer.ts","webpack:///./src/options/presets/NoCustomNodes.ts","webpack:///./src/enums/StringArrayEncoding.ts","webpack:///./src/stack-trace-analyzer/callee-data-extractors/AbstractCalleeDataExtractor.ts","webpack:///./src/utils/CryptUtils.ts","webpack:///./src/enums/JSFuck.ts","webpack:///./src/enums/container/CalleeDataExtractors.ts","webpack:///./src/enums/container/ControlFlowReplacers.ts","webpack:///./src/enums/container/CustomNodeGroups.ts","webpack:///./src/enums/container/NodeTransformers.ts","webpack:///./src/node-transformers/control-flow-transformers/control-flow-replacers/AbstractControlFlowReplacer.ts","webpack:///./src/node-transformers/control-flow-transformers/control-flow-replacers/ExpressionWithOperatorControlFlowReplacer.ts","webpack:///./src/options/presets/Default.ts","webpack:///./src/storages/MapStorage.ts","webpack:///external \"esprima\"","webpack:///external \"path\"","webpack:///./src/JavaScriptObfuscatorInternal.ts","webpack:///./src/ObfuscationResult.ts","webpack:///./src/Obfuscator.ts","webpack:///./src/SourceMapCorrector.ts","webpack:///./src/cli/CLIUtils.ts","webpack:///./src/cli/JavaScriptObfuscatorCLI.ts","webpack:///./src/container/InversifyContainerFacade.ts","webpack:///./src/container/modules/custom-nodes/CustomNodesModule.ts","webpack:///./src/container/modules/node-transformers/ControlFlowTransformersModule.ts","webpack:///./src/container/modules/node-transformers/NodeTransformersModule.ts","webpack:///./src/container/modules/node-transformers/ObfuscatingTransformersModule.ts","webpack:///./src/container/modules/stack-trace-analyzer/StackTraceAnalyzerModule.ts","webpack:///./src/container/modules/storages/StoragesModule.ts","webpack:///./src/custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode.ts","webpack:///./src/custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup.ts","webpack:///./src/custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode.ts","webpack:///./src/custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode.ts","webpack:///./src/custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode.ts","webpack:///./src/custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode.ts","webpack:///./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode.ts","webpack:///./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode.ts","webpack:///./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode.ts","webpack:///./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode.ts","webpack:///./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode.ts","webpack:///./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode.ts","webpack:///./src/custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup.ts","webpack:///./src/custom-nodes/domain-lock-nodes/DomainLockNode.ts","webpack:///./src/custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup.ts","webpack:///./src/custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode.ts","webpack:///./src/custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode.ts","webpack:///./src/custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup.ts","webpack:///./src/custom-nodes/string-array-nodes/StringArrayCallsWrapper.ts","webpack:///./src/custom-nodes/string-array-nodes/StringArrayNode.ts","webpack:///./src/custom-nodes/string-array-nodes/StringArrayRotateFunctionNode.ts","webpack:///./src/custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup.ts","webpack:///./src/enums/VisitorDirection.ts","webpack:///./src/event-emitters/ObfuscationEventEmitter.ts","webpack:///./src/node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer.ts","webpack:///./src/node-transformers/control-flow-transformers/FunctionControlFlowTransformer.ts","webpack:///./src/node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer.ts","webpack:///./src/node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer.ts","webpack:///./src/node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer.ts","webpack:///./src/node-transformers/converting-transformers/MemberExpressionTransformer.ts","webpack:///./src/node-transformers/converting-transformers/MethodDefinitionTransformer.ts","webpack:///./src/node-transformers/converting-transformers/TemplateLiteralTransformer.ts","webpack:///./src/node-transformers/obfuscating-transformers/CatchClauseTransformer.ts","webpack:///./src/node-transformers/obfuscating-transformers/FunctionDeclarationTransformer.ts","webpack:///./src/node-transformers/obfuscating-transformers/FunctionTransformer.ts","webpack:///./src/node-transformers/obfuscating-transformers/LabeledStatementTransformer.ts","webpack:///./src/node-transformers/obfuscating-transformers/LiteralTransformer.ts","webpack:///./src/node-transformers/obfuscating-transformers/ObjectExpressionTransformer.ts","webpack:///./src/node-transformers/obfuscating-transformers/VariableDeclarationTransformer.ts","webpack:///./src/node-transformers/obfuscating-transformers/replacers/BooleanLiteralReplacer.ts","webpack:///./src/node-transformers/obfuscating-transformers/replacers/IdentifierReplacer.ts","webpack:///./src/node-transformers/obfuscating-transformers/replacers/NumberLiteralReplacer.ts","webpack:///./src/node-transformers/obfuscating-transformers/replacers/StringLiteralReplacer.ts","webpack:///./src/options/Options.ts","webpack:///./src/options/OptionsNormalizer.ts","webpack:///./src/options/ValidationErrorsFormatter.ts","webpack:///./src/stack-trace-analyzer/StackTraceAnalyzer.ts","webpack:///./src/stack-trace-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor.ts","webpack:///./src/stack-trace-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor.ts","webpack:///./src/stack-trace-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor.ts","webpack:///./src/storages/ArrayStorage.ts","webpack:///./src/storages/control-flow/ControlFlowStorage.ts","webpack:///./src/storages/custom-node-group/CustomNodeGroupStorage.ts","webpack:///./src/storages/string-array/StringArrayStorage.ts","webpack:///./src/templates/custom-nodes/AtobTemplate.ts","webpack:///./src/templates/custom-nodes/Rc4Template.ts","webpack:///./src/templates/custom-nodes/SingleNodeCallControllerTemplate.ts","webpack:///./src/templates/custom-nodes/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate.ts","webpack:///./src/templates/custom-nodes/debug-protection-nodes/debug-protection-function-call-node/DebufProtectionFunctionCallTemplate.ts","webpack:///./src/templates/custom-nodes/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate.ts","webpack:///./src/templates/custom-nodes/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate.ts","webpack:///./src/templates/custom-nodes/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate.ts","webpack:///./src/templates/custom-nodes/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate.ts","webpack:///./src/templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate.ts","webpack:///./src/templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate.ts","webpack:///./src/templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate.ts","webpack:///./src/templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate.ts","webpack:///./src/templates/custom-nodes/string-array-nodes/string-array-node/StringArrayTemplate.ts","webpack:///./src/templates/custom-nodes/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate.ts","webpack:///./src/templates/custom-nodes/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate.ts","webpack:///external \"chance\"","webpack:///external \"class-validator\"","webpack:///external \"commander\"","webpack:///external \"events\"","webpack:///external \"fs\"","webpack:///external \"mkdirp\"","webpack:///external \"reflect-metadata\"","webpack:///./index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 128);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b0ba8199125b1109305c","module.exports = require(\"inversify\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"inversify\"\n// module id = 0\n// module chunks = 0","module.exports = require(\"tslib\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"tslib\"\n// module id = 1\n// module chunks = 0","export const ServiceIdentifiers: any = {\n    Factory__ICalleeDataExtractor: Symbol('Factory<ICalleeDataExtractor>'),\n    Factory__IControlFlowReplacer: Symbol('Factory<IControlFlowReplacer>'),\n    Factory__ICustomNode: Symbol('Factory<ICustomNode>'),\n    Factory__ICustomNodeGroup: Symbol('Factory<ICustomNodeGroup>'),\n    Factory__INodeTransformer: Symbol('Factory<INodeTransformer[]>'),\n    Factory__IObfuscationResult: Symbol('Factory<IObfuscationResult>'),\n    Factory__IObfuscationReplacer: Symbol('Factory<IObfuscationReplacer>'),\n    Factory__TControlFlowStorage: Symbol('Factory<TControlFlowStorage>'),\n    ICalleeDataExtractor: Symbol('ICalleeDataExtractor'),\n    ICustomNodeGroup: Symbol('ICustomNodeGroup'),\n    IControlFlowReplacer: Symbol('IControlFlowReplacer'),\n    IJavaScriptObfuscator: Symbol('IJavaScriptObfuscator'),\n    INodeTransformer: Symbol('INodeTransformer'),\n    IObfuscationEventEmitter: Symbol('IObfuscationEventEmitter'),\n    IObfuscationResult: Symbol('IObfuscationResult'),\n    IObfuscator: Symbol('IObfuscator'),\n    IOptions: Symbol('IOptions'),\n    IObfuscationReplacer: Symbol('IObfuscationReplacer'),\n    ISourceMapCorrector: Symbol('ISourceMapCorrector'),\n    IStackTraceAnalyzer: Symbol('IStackTraceAnalyzer'),\n    Newable__ICustomNode: Symbol('Newable<ICustomNode>'),\n    Newable__TControlFlowStorage: Symbol('Newable<TControlFlowStorage>'),\n    TCustomNodeGroupStorage: Symbol('TCustomNodeGroupStorage'),\n    TStringArrayStorage: Symbol('TStringArrayStorage')\n};\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/container/ServiceIdentifiers.ts","import * as escodegen from 'escodegen-wallaby';\nimport * as esprima from 'esprima';\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeWithBlockStatement } from '../types/node/TNodeWithBlockStatement';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { NodeType } from '../enums/NodeType';\n\nimport { Node } from './Node';\nimport { Nodes } from './Nodes';\n\nexport class NodeUtils {\n    /**\n     * @type {string[]}\n     */\n    private static readonly nodesWithBlockScope: string[] = [\n        NodeType.ArrowFunctionExpression,\n        NodeType.FunctionDeclaration,\n        NodeType.FunctionExpression,\n        NodeType.MethodDefinition,\n        NodeType.Program\n    ];\n\n    /**\n     * @param astTree\n     * @return {T}\n     */\n    public static addXVerbatimPropertyToLiterals <T extends ESTree.Node> (astTree: T): T {\n        NodeUtils.typedReplace(astTree, NodeType.Literal, {\n            leave: (literalNode: ESTree.Literal) => {\n                literalNode['x-verbatim-property'] = {\n                    content : literalNode.raw,\n                    precedence: escodegen.Precedence.Primary\n                };\n            }\n        });\n\n        return astTree;\n    }\n\n    /**\n     * @param code\n     * @returns {TStatement[]}\n     */\n    public static convertCodeToStructure (code: string): TStatement[] {\n        let structure: ESTree.Program = esprima.parse(code);\n\n        structure = NodeUtils.addXVerbatimPropertyToLiterals(structure);\n        structure = NodeUtils.parentize(structure);\n\n        return <TStatement[]>structure.body;\n    }\n\n    /**\n     * @param structure\n     * @returns {string}\n     */\n    public static convertStructureToCode (structure: ESTree.Node[]): string {\n        let code: string = '';\n\n        structure.forEach((node: ESTree.Node) => {\n            code += escodegen.generate(node, {\n                sourceMapWithCode: true\n            }).code;\n        });\n\n        return code;\n    }\n\n    /**\n     * @param node\n     * @param index\n     * @returns {ESTree.Node}\n     */\n    public static getBlockStatementNodeByIndex (node: ESTree.Node, index: number = 0): ESTree.Node {\n        if (Node.isNodeHasBlockStatement(node)) {\n            if (node.body[index] === undefined) {\n                throw new ReferenceError(`Wrong index \\`${index}\\`. Block-statement body length is \\`${node.body.length}\\``);\n            }\n\n            return node.body[index];\n        }\n\n        throw new TypeError('The specified node have no a block-statement');\n    }\n\n    /**\n     * @param node\n     * @param blockScopes\n     * @returns {ESTree.Node}\n     */\n    public static getBlockScopesOfNode (node: ESTree.Node, blockScopes: TNodeWithBlockStatement[] = []): TNodeWithBlockStatement[] {\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (Node.isBlockStatementNode(parentNode)) {\n            if (!parentNode.parentNode) {\n                throw new ReferenceError('`parentNode` property of `parentNode` of given node is `undefined`');\n            }\n\n            if (NodeUtils.nodesWithBlockScope.includes(parentNode.parentNode.type)) {\n                blockScopes.push(parentNode);\n            }\n        }\n\n        if (!Node.isProgramNode(parentNode)) {\n            return NodeUtils.getBlockScopesOfNode(parentNode, blockScopes);\n        }\n\n        blockScopes.push(parentNode);\n\n        return blockScopes;\n    }\n\n    /**\n     * @param node\n     * @param depth\n     * @returns {number}\n     */\n    public static getNodeBlockScopeDepth (node: ESTree.Node, depth: number = 0): number {\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (Node.isProgramNode(parentNode)) {\n            return depth;\n        }\n\n        if (Node.isBlockStatementNode(node) && NodeUtils.nodesWithBlockScope.includes(parentNode.type)) {\n            return NodeUtils.getNodeBlockScopeDepth(parentNode, ++depth);\n        }\n\n        return NodeUtils.getNodeBlockScopeDepth(parentNode, depth);\n    }\n\n    /**\n     * @param unaryExpressionNode\n     * @returns {ESTree.Node}\n     */\n    public static getUnaryExpressionArgumentNode (unaryExpressionNode: ESTree.UnaryExpression): ESTree.Node {\n        if (Node.isUnaryExpressionNode(unaryExpressionNode.argument)) {\n            return NodeUtils.getUnaryExpressionArgumentNode(unaryExpressionNode.argument);\n        }\n\n        return unaryExpressionNode.argument;\n    }\n\n    /**\n     * @param astTree\n     * @return {T}\n     */\n    public static parentize <T extends ESTree.Node> (astTree: T): T {\n        let isRootNode: boolean = true;\n\n        estraverse.traverse(astTree, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                let value: ESTree.Node;\n\n                if (isRootNode) {\n                    if (node.type === NodeType.Program) {\n                        value = node;\n                    } else {\n                        value = Nodes.getProgramNode(<TStatement[]>[node]);\n                        value.parentNode = value;\n                    }\n\n                    isRootNode = false;\n                } else {\n                    value = parentNode || node;\n                }\n\n                node.parentNode = value;\n                node.obfuscatedNode = false;\n            }\n        });\n\n        return astTree;\n    }\n\n    /**\n     * @param astTree\n     * @param nodeType\n     * @param visitor\n     */\n    public static typedReplace (\n        astTree: ESTree.Node,\n        nodeType: string,\n        visitor: {enter?: (node: ESTree.Node) => void, leave?: (node: ESTree.Node) => void},\n    ): void {\n        NodeUtils.typedTraverse(astTree, nodeType, visitor, 'replace');\n    }\n\n    /**\n     * @param astTree\n     * @param nodeType\n     * @param visitor\n     * @param traverseType\n     */\n    public static typedTraverse (\n        astTree: ESTree.Node,\n        nodeType: string,\n        visitor: estraverse.Visitor,\n        traverseType: string = 'traverse'\n    ): void {\n        (<any>estraverse)[traverseType](astTree, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (node.type === nodeType && visitor.enter) {\n                    return visitor.enter(node, parentNode);\n                }\n            },\n            leave: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (node.type === nodeType && visitor.leave) {\n                    return visitor.leave(node, parentNode);\n                }\n            }\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node/NodeUtils.ts","import { Chance } from 'chance';\n\nimport { Utils } from './Utils';\n\nexport class RandomGeneratorUtils {\n    /**\n     * @type {string}\n     */\n    public static readonly randomGeneratorPool: string = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n    /**\n     * @type {string}\n     */\n    public static readonly randomGeneratorPoolNumbers: string = '0123456789';\n\n    /**\n     * @type {string}\n     */\n    public static readonly randomGeneratorPoolHexadecimal: string = `abcdef${RandomGeneratorUtils.randomGeneratorPoolNumbers}`;\n\n    /**\n     * @type {string}\n     */\n    public static readonly randomGeneratorPoolWithNumbers: string = `${RandomGeneratorUtils.randomGeneratorPool}${RandomGeneratorUtils.randomGeneratorPoolNumbers}`;\n\n    /**\n     * @type {Set<string>}\n     */\n    public static readonly randomVariableNameSet: Set <string> = new Set();\n\n    /**\n     * @type {Chance.Chance | Chance.SeededChance}\n     */\n    private static randomGenerator: Chance.Chance | Chance.SeededChance;\n\n    /**\n     * @param seed\n     */\n    public static initializeRandomGenerator (seed: number): void {\n        if (seed !== 0) {\n            RandomGeneratorUtils.randomGenerator = new Chance(seed);\n        } else {\n            RandomGeneratorUtils.randomGenerator = new Chance();\n        }\n    }\n\n    public static clearRandomGenerator (): void {\n        RandomGeneratorUtils.randomVariableNameSet.clear();\n    }\n\n    /**\n     * @returns {number}\n     */\n    public static getMathRandom (): number {\n        return RandomGeneratorUtils.getRandomInteger(0, 99999) / 100000;\n    }\n\n    /**\n     * @param min\n     * @param max\n     * @returns {number}\n     */\n    public static getRandomFloat (min: number, max: number): number {\n        return RandomGeneratorUtils.getRandomGenerator().floating({\n            min: min,\n            max: max,\n            fixed: 7\n        });\n    }\n\n    /**\n     * @returns {Chance.Chance}\n     */\n    public static getRandomGenerator (): Chance.Chance {\n        const randomGenerator: Chance.Chance = RandomGeneratorUtils.randomGenerator;\n\n        if (!randomGenerator) {\n            RandomGeneratorUtils.initializeRandomGenerator(0);\n        }\n\n        return RandomGeneratorUtils.randomGenerator;\n    }\n\n    /**\n     * @param min\n     * @param max\n     * @returns {number}\n     */\n    public static getRandomInteger (min: number, max: number): number {\n        return RandomGeneratorUtils.getRandomGenerator().integer({\n            min: min,\n            max: max\n        });\n    }\n\n    /**\n     * @param length\n     * @param pool\n     * @returns {string}\n     */\n    public static getRandomString (length: number, pool: string = RandomGeneratorUtils.randomGeneratorPool): string {\n        return RandomGeneratorUtils.getRandomGenerator().string({ length, pool });\n    }\n\n    /**\n     * @param length\n     * @returns {string}\n     */\n    public static getRandomVariableName (length: number): string {\n        const prefix: string = `_${Utils.hexadecimalPrefix}`;\n        const rangeMinInteger: number = 10000;\n        const rangeMaxInteger: number = 99999999;\n        const randomVariableName: string = `${prefix}${(\n            Utils.decToHex(\n                RandomGeneratorUtils.getRandomInteger(rangeMinInteger, rangeMaxInteger)\n            )\n        ).substr(0, length)}`;\n\n        if (RandomGeneratorUtils.randomVariableNameSet.has(randomVariableName)) {\n            return RandomGeneratorUtils.getRandomVariableName(length);\n        }\n\n        RandomGeneratorUtils.randomVariableNameSet.add(randomVariableName);\n\n        return randomVariableName;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/utils/RandomGeneratorUtils.ts","/* tslint:disable:no-invalid-this */\n\nimport { IInitializable } from '../interfaces/IInitializable';\n\n/**\n * @param initializeMethodKey\n * @returns {(target:IInitializable, propertyKey:(string|symbol))=>PropertyDescriptor}\n */\nexport function initializable (\n    initializeMethodKey: string = 'initialize'\n): (target: IInitializable, propertyKey: string | symbol) => any {\n    const decoratorName: string = Object.keys(this)[0];\n\n    return (target: IInitializable, propertyKey: string | symbol): any => {\n        const descriptor: PropertyDescriptor = {\n            configurable: true,\n            enumerable: true\n        };\n        const initializeMethod: any = (<any>target)[initializeMethodKey];\n\n        if (!initializeMethod || typeof initializeMethod !== 'function') {\n           throw new Error(`\\`${initializeMethodKey}\\` method with initialization logic not found. \\`@${decoratorName}\\` decorator requires \\`${initializeMethodKey}\\` method`);\n        }\n\n        const metadataPropertyKey: string = `_${propertyKey}`;\n        const propertyDescriptor: PropertyDescriptor = Object.getOwnPropertyDescriptor(target, metadataPropertyKey) || descriptor;\n        const methodDescriptor: PropertyDescriptor = Object.getOwnPropertyDescriptor(target, initializeMethodKey) || descriptor;\n        const originalMethod: Function = methodDescriptor.value;\n\n        Object.defineProperty(target, propertyKey, {\n            ...propertyDescriptor,\n            get: function (): any {\n                if (this[metadataPropertyKey] === undefined) {\n                    throw new Error(`Property \\`${propertyKey}\\` is not initialized! Initialize it first!`);\n                }\n\n                return this[metadataPropertyKey];\n            },\n            set: function (newVal: any): void {\n                this[metadataPropertyKey] = newVal;\n            }\n        });\n        Object.defineProperty(target, initializeMethodKey, {\n            ...methodDescriptor,\n            value: function (): void {\n                originalMethod.apply(this, arguments);\n\n                if (this[propertyKey]) {}\n            }\n        });\n\n        return propertyDescriptor;\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/decorators/Initializable.ts","import * as ESTree from 'estree';\n\nimport { TNodeWithBlockStatement } from '../types/node/TNodeWithBlockStatement';\n\nimport { NodeType } from '../enums/NodeType';\n\nexport class Node {\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isArrowFunctionExpressionNode (node: ESTree.Node): node is ESTree.ArrowFunctionExpression {\n        return node.type === NodeType.ArrowFunctionExpression;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isAssignmentPatternNode (node: ESTree.Node): node is ESTree.AssignmentPattern {\n        return node.type === NodeType.AssignmentPattern;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isBlockStatementNode (node: ESTree.Node): node is ESTree.BlockStatement {\n        return node.type === NodeType.BlockStatement;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isBreakStatementNode (node: ESTree.Node): node is ESTree.BreakStatement {\n        return node.type === NodeType.BreakStatement;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isCallExpressionNode (node: ESTree.Node): node is ESTree.CallExpression {\n        return node.type === NodeType.CallExpression;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isCatchClauseNode (node: ESTree.Node): node is ESTree.CatchClause {\n        return node.type === NodeType.CatchClause;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isContinueStatementNode (node: ESTree.Node): node is ESTree.ContinueStatement {\n        return node.type === NodeType.ContinueStatement;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isExpressionStatementNode (node: ESTree.Node): node is ESTree.ExpressionStatement {\n        return node.type === NodeType.ExpressionStatement;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isFunctionDeclarationNode (node: ESTree.Node): node is ESTree.FunctionDeclaration {\n        return node.type === NodeType.FunctionDeclaration;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isFunctionExpressionNode (node: ESTree.Node): node is ESTree.FunctionExpression {\n        return node.type === NodeType.FunctionExpression;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isIdentifierNode (node: ESTree.Node): node is ESTree.Identifier {\n        return node.type === NodeType.Identifier;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isIfStatementNode (node: ESTree.Node): node is ESTree.IfStatement {\n        return node.type === NodeType.IfStatement;\n    }\n\n    /**\n     * @param node\n     * @param parentNode\n     * @returns {boolean}\n     */\n    public static isLabelIdentifierNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        const parentNodeIsLabeledStatementNode: boolean = Node.isLabeledStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsContinueStatementNode: boolean = Node.isContinueStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsBreakStatementNode: boolean = Node.isBreakStatementNode(parentNode) && parentNode.label === node;\n\n        return parentNodeIsLabeledStatementNode || parentNodeIsContinueStatementNode || parentNodeIsBreakStatementNode;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isLabeledStatementNode (node: ESTree.Node): node is ESTree.LabeledStatement {\n        return node.type === NodeType.LabeledStatement;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isLiteralNode (node: ESTree.Node): node is ESTree.Literal {\n        return node.type === NodeType.Literal;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isMemberExpressionNode (node: ESTree.Node): node is ESTree.MemberExpression {\n        return node.type === NodeType.MemberExpression;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isMethodDefinitionNode (node: ESTree.Node): node is ESTree.MethodDefinition {\n        return node.type === NodeType.MethodDefinition;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isObjectPatternNode (node: ESTree.Node): node is ESTree.ObjectPattern {\n        return node.type === NodeType.ObjectPattern;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isObjectExpressionNode (node: ESTree.Node): node is ESTree.ObjectExpression {\n        return node.type === NodeType.ObjectExpression;\n    }\n\n    /**\n     *\n     * @param node\n     * @returns {boolean}\n     */\n    public static isProgramNode (node: ESTree.Node): node is ESTree.Program {\n        return node.type === NodeType.Program;\n    }\n\n    /**\n     *\n     * @param node\n     * @returns {boolean}\n     */\n    public static isPropertyNode (node: ESTree.Node): node is ESTree.Property {\n        return node.type === NodeType.Property;\n    }\n\n    /**\n     * @param node\n     * @param parentNode\n     * @returns {boolean}\n     */\n    public static isReplaceableIdentifierNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        if (!Node.isIdentifierNode(node)) {\n            return false;\n        }\n\n        const parentNodeIsPropertyNode: boolean = Node.isPropertyNode(parentNode) && parentNode.key === node;\n        const parentNodeIsMemberExpressionNode: boolean = (\n            Node.isMemberExpressionNode(parentNode) &&\n            parentNode.computed === false &&\n            parentNode.property === node\n        );\n\n        return !parentNodeIsPropertyNode && !parentNodeIsMemberExpressionNode && !Node.isLabelIdentifierNode(node, parentNode);\n    }\n\n    /**\n     *\n     * @param node\n     * @returns {boolean}\n     */\n    public static isTemplateLiteralNode (node: ESTree.Node): node is ESTree.TemplateLiteral {\n        return node.type === NodeType.TemplateLiteral;\n    }\n\n    /**\n     *\n     * @param node\n     * @returns {boolean}\n     */\n    public static isUnaryExpressionNode (node: ESTree.Node): node is ESTree.UnaryExpression {\n        return node.type === NodeType.UnaryExpression;\n    }\n\n    /**\n     *\n     * @param node\n     * @returns {boolean}\n     */\n    public static isVariableDeclarationNode (node: ESTree.Node): node is ESTree.VariableDeclaration {\n        return node.type === NodeType.VariableDeclaration;\n    }\n\n    /**\n     *\n     * @param node\n     * @returns {boolean}\n     */\n    public static isVariableDeclaratorNode (node: ESTree.Node): node is ESTree.VariableDeclarator {\n        return node.type === NodeType.VariableDeclarator;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isNodeHasBlockStatement (node: ESTree.Node): node is TNodeWithBlockStatement {\n        return node.hasOwnProperty('body') && Array.isArray((<TNodeWithBlockStatement>node).body);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node/Node.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { NodeUtils } from '../node/NodeUtils';\n\n@injectable()\nexport abstract class AbstractCustomNode implements ICustomNode {\n    /**\n     * @type {string}\n     */\n    protected cachedCode: string;\n\n    /**\n     * @type {TStatement[]}\n     */\n    protected cachedNode: TStatement[];\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @param args\n     */\n    public abstract initialize (...args: any[]): void;\n\n    /**\n     * @returns {string}\n     */\n    public getCode (): string {\n        if (!this.cachedCode) {\n            this.cachedCode = NodeUtils.convertStructureToCode(this.getNode());\n        }\n\n        return this.cachedCode;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        if (!this.cachedNode) {\n            this.cachedNode = this.getNodeStructure();\n        }\n\n        return this.cachedNode;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected abstract getNodeStructure (): TStatement[];\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/AbstractCustomNode.ts","import { JSFuck } from '../enums/JSFuck';\n\nimport { RandomGeneratorUtils } from './RandomGeneratorUtils';\n\nexport class Utils {\n    /**\n     * @type {string}\n     */\n    public static readonly hexadecimalPrefix: string = '0x';\n\n    /**\n     * @type {Map<string, string>}\n     */\n    private static readonly stringToUnicodeEscapeSequenceCache: Map <string, string> = new Map();\n\n    /**\n     * @param length\n     * @return {number[]}\n     */\n    public static arrayRange (length: number): number[] {\n        const range: number[] = [];\n\n        for (let i: number = 0; i < length; i++) {\n            range.push(i);\n        }\n\n        return range;\n    }\n\n    /**\n     * @param array\n     * @param times\n     * @returns {T[]}\n     */\n    public static arrayRotate <T> (array: T[], times: number): T[] {\n        if (!array.length) {\n            throw new ReferenceError(`Cannot rotate empty array.`);\n        }\n\n        if (times <= 0) {\n            return array;\n        }\n\n        const newArray: T[] = array;\n\n        let temp: T | undefined;\n\n        while (times--) {\n            temp = newArray.pop()!;\n            newArray.unshift(temp);\n        }\n\n        return newArray;\n    }\n\n    /**\n     * @param array\n     * @return {T[]}\n     */\n    public static arrayShuffle <T> (array: T[]): T[] {\n        const shuffledArray: T[] = [...array];\n\n        for (let i: number = shuffledArray.length; i; i--) {\n            const j: number = Math.floor(RandomGeneratorUtils.getMathRandom() * i);\n\n            [shuffledArray[i - 1], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i - 1]];\n        }\n\n        return shuffledArray;\n    }\n\n    /**\n     * @param dec\n     * @returns {string}\n     */\n    public static decToHex (dec: number): string {\n        const radix: number = 16;\n\n        return dec.toString(radix);\n    }\n\n    /**\n     * @param url\n     * @returns {string}\n     */\n    public static extractDomainFromUrl (url: string): string {\n        let domain: string;\n\n        if (url.indexOf('://') > -1 || url.indexOf('//') === 0) {\n            domain = url.split('/')[2];\n        } else {\n            domain = url.split('/')[0];\n        }\n\n        domain = domain.split(':')[0];\n\n        return domain;\n    }\n\n    /**\n     * @param number\n     * @returns {boolean}\n     */\n    public static isCeilNumber (number: number): boolean {\n        return number % 1 === 0;\n    }\n\n    /**\n     * @param obj\n     * @returns {T}\n     */\n    public static strEnumify <T extends {[prop: string]: ''|string}> (obj: T): T {\n        return obj;\n    }\n\n    /**\n     * @param string\n     * @param times\n     * @returns {string}\n     */\n    public static stringRotate (string: string, times: number): string {\n        if (!string) {\n            throw new ReferenceError(`Cannot rotate empty string.`);\n        }\n\n        for (let i: number = 0; i < times; i++) {\n            string = string[string.length - 1] + string.substring(0, string.length - 1);\n        }\n\n        return string;\n    }\n\n    /**\n     * @param string\n     * @returns {string}\n     */\n    public static stringToJSFuck (string: string): string {\n        return Array\n            .from(string)\n            .map((character: string): string => {\n                return JSFuck[character] || character;\n            })\n            .join(' + ');\n    }\n\n    /**\n     * @param string\n     * @param nonLatinAndNonDigitsOnly\n     * @returns {string}\n     */\n    public static stringToUnicodeEscapeSequence (string: string, nonLatinAndNonDigitsOnly: boolean = false): string {\n        const cacheKey: string = `${string}-${String(nonLatinAndNonDigitsOnly)}`;\n\n        if (Utils.stringToUnicodeEscapeSequenceCache.has(cacheKey)) {\n            return <string>Utils.stringToUnicodeEscapeSequenceCache.get(cacheKey);\n        }\n\n        const radix: number = 16;\n        const replaceRegExp: RegExp = new RegExp('[\\\\s\\\\S]', 'g');\n        const escapeRegExp: RegExp = new RegExp('[^a-zA-Z0-9]');\n        const regexp: RegExp = new RegExp('[\\\\x00-\\\\x7F]');\n\n        let prefix: string,\n            template: string;\n\n        const result: string = string.replace(replaceRegExp, (escape: string): string => {\n            if (nonLatinAndNonDigitsOnly && !escapeRegExp.exec(escape)) {\n                return escape;\n            }\n\n            if (regexp.exec(escape)) {\n                prefix = '\\\\x';\n                template = '00';\n            } else {\n                prefix = '\\\\u';\n                template = '0000';\n            }\n\n            return `${prefix}${(template + escape.charCodeAt(0).toString(radix)).slice(-template.length)}`;\n        });\n\n        Utils.stringToUnicodeEscapeSequenceCache.set(cacheKey, result);\n\n        return result;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/utils/Utils.ts","export enum CustomNodes {\n    BinaryExpressionFunctionNode,\n    BlockStatementControlFlowFlatteningNode,\n    CallExpressionControlFlowStorageCallNode,\n    CallExpressionFunctionNode,\n    ControlFlowStorageNode,\n    ConsoleOutputDisableExpressionNode,\n    DebugProtectionFunctionCallNode,\n    DebugProtectionFunctionIntervalNode,\n    DebugProtectionFunctionNode,\n    DomainLockNode,\n    ExpressionWithOperatorControlFlowStorageCallNode,\n    LogicalExpressionFunctionNode,\n    NodeCallsControllerFunctionNode,\n    SelfDefendingUnicodeNode,\n    StringArrayCallsWrapper,\n    StringArrayNode,\n    StringArrayRotateFunctionNode\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/enums/container/CustomNodes.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { INodeTransformer } from '../interfaces/node-transformers/INodeTransformer';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IVisitor } from '../interfaces/IVisitor';\n\nimport { RandomGeneratorUtils } from '../utils/RandomGeneratorUtils';\n\n@injectable()\nexport abstract class AbstractNodeTransformer implements INodeTransformer {\n    /**\n     * @type {number}\n     */\n    protected nodeIdentifier: number = RandomGeneratorUtils.getRandomInteger(0, 10000);\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @returns {IVisitor}\n     */\n    public abstract getVisitor (): IVisitor;\n\n    /**\n     * @param node\n     * @param parentNode\n     * @returns {ESTree.Node}\n     */\n    public abstract transformNode (node: ESTree.Node, parentNode: ESTree.Node): ESTree.Node;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/AbstractNodeTransformer.ts","module.exports = require(\"estraverse\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"estraverse\"\n// module id = 11\n// module chunks = 0","module.exports = require(\"string-template\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"string-template\"\n// module id = 12\n// module chunks = 0","import { Utils } from '../utils/Utils';\n\nexport const NodeType: any = Utils.strEnumify({\n    ArrayExpression: 'ArrayExpression',\n    ArrowFunctionExpression: 'ArrowFunctionExpression',\n    AssignmentExpression: 'AssignmentExpression',\n    AssignmentPattern: 'AssignmentPattern',\n    BinaryExpression: 'BinaryExpression',\n    BlockStatement: 'BlockStatement',\n    BreakStatement: 'BreakStatement',\n    CallExpression: 'CallExpression',\n    CatchClause: 'CatchClause',\n    ClassDeclaration: 'ClassDeclaration',\n    ContinueStatement: 'ContinueStatement',\n    ExpressionStatement: 'ExpressionStatement',\n    FunctionDeclaration: 'FunctionDeclaration',\n    FunctionExpression: 'FunctionExpression',\n    Identifier:  'Identifier',\n    IfStatement:  'IfStatement',\n    LabeledStatement: 'LabeledStatement',\n    Literal: 'Literal',\n    LogicalExpression: 'LogicalExpression',\n    MemberExpression: 'MemberExpression',\n    MethodDefinition: 'MethodDefinition',\n    ObjectExpression: 'ObjectExpression',\n    ObjectPattern: 'ObjectPattern',\n    Program: 'Program',\n    Property: 'Property',\n    ReturnStatement: 'ReturnStatement',\n    SwitchCase: 'SwitchCase',\n    SwitchStatement: 'SwitchStatement',\n    TemplateLiteral: 'TemplateLiteral',\n    TryStatement: 'TryStatement',\n    UnaryExpression: 'UnaryExpression',\n    UpdateExpression: 'UpdateExpression',\n    VariableDeclaration: 'VariableDeclaration',\n    VariableDeclarator: 'VariableDeclarator',\n    WhileStatement: 'WhileStatement'\n});\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/enums/NodeType.ts","import * as escodegen from 'escodegen-wallaby';\nimport * as ESTree from 'estree';\n\nimport { TStatement } from '../types/node/TStatement';\n\nimport { NodeType } from '../enums/NodeType';\n\nexport class Nodes {\n    /**\n     * @param body\n     * @returns {ESTree.Program}\n     */\n    public static getProgramNode (body: TStatement[] = []): ESTree.Program {\n        return {\n            type: NodeType.Program,\n            body,\n            sourceType: 'script',\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param operator\n     * @param left\n     * @param right\n     * @return {ESTree.AssignmentExpression}\n     */\n    public static getAssignmentExpressionNode (\n        operator: ESTree.AssignmentOperator,\n        left: ESTree.Pattern | ESTree.MemberExpression,\n        right: ESTree.Expression\n    ): ESTree.AssignmentExpression {\n        return {\n            type: NodeType.AssignmentExpression,\n            operator,\n            left,\n            right,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param operator\n     * @param left\n     * @param right\n     * @returns {ESTree.BinaryExpression}\n     */\n    public static getBinaryExpressionNode (\n        operator: ESTree.BinaryOperator,\n        left: ESTree.Expression,\n        right: ESTree.Expression,\n    ): ESTree.BinaryExpression {\n        return {\n            type: NodeType.BinaryExpression,\n            operator,\n            left,\n            right,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param body\n     * @returns {ESTree.BlockStatement}\n     */\n    public static getBlockStatementNode (body: ESTree.Statement[] = []): ESTree.BlockStatement {\n        return {\n            type: NodeType.BlockStatement,\n            body,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param label\n     * @return {ESTree.BreakStatement}\n     */\n    public static getBreakStatement (label?: ESTree.Identifier): ESTree.BreakStatement {\n        const breakStatementNode: ESTree.BreakStatement = {\n            type: NodeType.BreakStatement,\n            obfuscatedNode: false\n        };\n\n        if (label) {\n            breakStatementNode.label = label;\n        }\n\n        return breakStatementNode;\n    }\n\n    /**\n     * @param body\n     * @returns {ESTree.CatchClause}\n     */\n    public static getCatchClauseNode (body: ESTree.Statement[] = []): ESTree.CatchClause {\n        return {\n            type: NodeType.CatchClause,\n            param: Nodes.getIdentifierNode('err'),\n            body: Nodes.getBlockStatementNode(body),\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param callee\n     * @param args\n     * @returns {ESTree.CallExpression}\n     */\n    public static getCallExpressionNode (\n        callee: ESTree.Expression,\n        args: (ESTree.Expression | ESTree.SpreadElement)[] = []\n    ): ESTree.CallExpression {\n        return {\n            type: NodeType.CallExpression,\n            callee,\n            arguments: args,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param label\n     * @return {ESTree.ContinueStatement}\n     */\n    public static getContinueStatement (label?: ESTree.Identifier): ESTree.ContinueStatement {\n        const continueStatementNode: ESTree.ContinueStatement = {\n            type: NodeType.ContinueStatement,\n            obfuscatedNode: false\n        };\n\n        if (label) {\n            continueStatementNode.label = label;\n        }\n\n        return continueStatementNode;\n    }\n\n    /**\n     * @param expression\n     * @returns {ESTree.ExpressionStatement}\n     */\n    public static getExpressionStatementNode (expression: ESTree.Expression): ESTree.ExpressionStatement {\n        return {\n            type: NodeType.ExpressionStatement,\n            expression,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param functionName\n     * @param params\n     * @param body\n     * @returns {ESTree.FunctionDeclaration}\n     */\n    public static getFunctionDeclarationNode (\n        functionName: string,\n        params: ESTree.Identifier[],\n        body: ESTree.BlockStatement\n    ): ESTree.FunctionDeclaration {\n        return {\n            type: NodeType.FunctionDeclaration,\n            id: Nodes.getIdentifierNode(functionName),\n            params,\n            body,\n            generator: false,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param params\n     * @param body\n     * @returns {ESTree.FunctionExpression}\n     */\n    public static getFunctionExpressionNode (\n        params: ESTree.Identifier[],\n        body: ESTree.BlockStatement\n    ): ESTree.FunctionExpression {\n        return {\n            type: NodeType.FunctionExpression,\n            params,\n            body,\n            generator: false,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param test\n     * @param consequent\n     * @returns {ESTree.IfStatement}\n     */\n    public static getIfStatementNode (test: ESTree.Expression, consequent: ESTree.BlockStatement): ESTree.IfStatement {\n        return {\n            type: NodeType.IfStatement,\n            test,\n            consequent,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param name\n     * @returns {ESTree.Identifier}\n     */\n    public static getIdentifierNode (name: string): ESTree.Identifier {\n        return {\n            type: NodeType.Identifier,\n            name,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param label\n     * @param body\n     * @returns {ESTree.LabeledStatement}\n     */\n    public static getLabeledStatement (label: ESTree.Identifier, body: ESTree.Statement): ESTree.LabeledStatement {\n        return {\n            type: NodeType.LabeledStatement,\n            label,\n            body,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param value\n     * @returns {ESTree.Literal}\n     */\n    public static getLiteralNode (value: boolean|number|string): ESTree.Literal {\n        return {\n            type: NodeType.Literal,\n            value,\n            raw: `'${value}'`,\n            'x-verbatim-property': {\n                content: `'${value}'`,\n                precedence: escodegen.Precedence.Primary\n            },\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param operator\n     * @param left\n     * @param right\n     * @returns {ESTree.LogicalExpression}\n     */\n    public static getLogicalExpressionNode (\n        operator: ESTree.LogicalOperator,\n        left: ESTree.Expression,\n        right: ESTree.Expression,\n    ): ESTree.LogicalExpression {\n        return {\n            type: NodeType.LogicalExpression,\n            operator,\n            left,\n            right,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param object\n     * @param property\n     * @param computed\n     * @return {ESTree.MemberExpression}\n     */\n    public static getMemberExpressionNode (\n        object: ESTree.Expression | ESTree.Super,\n        property: ESTree.Expression,\n        computed: boolean = false\n    ): ESTree.MemberExpression {\n        return {\n            type: NodeType.MemberExpression,\n            computed,\n            object,\n            property,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param properties\n     * @return {ESTree.ObjectExpression}\n     */\n    public static getObjectExpressionNode (properties: ESTree.Property[]): ESTree.ObjectExpression {\n        return {\n            type: NodeType.ObjectExpression,\n            properties,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @return {ESTree.Property}\n     */\n    public static getPropertyNode (\n        key: ESTree.Expression,\n        value: ESTree.Expression | ESTree.Pattern,\n        computed: boolean = false\n    ): ESTree.Property {\n        return {\n            type: NodeType.Property,\n            key,\n            value,\n            kind: 'init',\n            method: false,\n            shorthand: false,\n            computed,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param operator\n     * @param argument\n     * @param prefix\n     * @returns {ESTree.Literal}\n     */\n    public static getUnaryExpressionNode (\n        operator: ESTree.UnaryOperator,\n        argument: ESTree.Expression,\n        prefix: boolean = true\n    ): ESTree.UnaryExpression {\n        return {\n            type: NodeType.UnaryExpression,\n            operator,\n            argument,\n            prefix,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param argument\n     * @return {ReturnStatement}\n     */\n    public static getReturnStatementNode (argument: ESTree.Expression): ESTree.ReturnStatement {\n        return {\n            type: NodeType.ReturnStatement,\n            argument,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param discriminant\n     * @param cases\n     * @returns {ESTree.SwitchStatement}\n     */\n    public static getSwitchStatementNode (\n        discriminant: ESTree.Expression,\n        cases: ESTree.SwitchCase[]\n    ): ESTree.SwitchStatement {\n        return {\n            type: NodeType.SwitchStatement,\n            discriminant,\n            cases,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param test\n     * @param consequent\n     * @returns {ESTree.SwitchCase}\n     */\n    public static getSwitchCaseNode (test: ESTree.Expression, consequent: ESTree.Statement[]): ESTree.SwitchCase {\n        return {\n            type: NodeType.SwitchCase,\n            test,\n            consequent,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param operator\n     * @param argumentExpr\n     * @returns {ESTree.UpdateExpression}\n     */\n    public static getUpdateExpressionNode (operator: ESTree.UpdateOperator, argumentExpr: ESTree.Expression): ESTree.UpdateExpression {\n        return {\n            type: NodeType.UpdateExpression,\n            operator,\n            argument: argumentExpr,\n            prefix: false,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param declarations\n     * @param kind\n     * @returns {ESTree.VariableDeclaration}\n     */\n    public static getVariableDeclarationNode (\n        declarations: ESTree.VariableDeclarator[] = [],\n        kind: 'var' | 'let' | 'const' = 'var'\n    ): ESTree.VariableDeclaration {\n        return {\n            type: NodeType.VariableDeclaration,\n            declarations,\n            kind,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param id\n     * @param init\n     * @returns {ESTree.VariableDeclarator}\n     */\n    public static getVariableDeclaratorNode (id: ESTree.Identifier, init: any): ESTree.VariableDeclarator {\n        return {\n            type: NodeType.VariableDeclarator,\n            id,\n            init,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param test\n     * @param body\n     * @return {ESTree.WhileStatement}\n     */\n    public static getWhileStatementNode (test: ESTree.Expression, body: ESTree.Statement): ESTree.WhileStatement {\n        return {\n            type: NodeType.WhileStatement,\n            test,\n            body,\n            obfuscatedNode: false\n        };\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node/Nodes.ts","import { TObfuscationEvent } from '../types/event-emitters/TObfuscationEvent';\n\nexport const ObfuscationEvents: {\n    AfterObfuscation: TObfuscationEvent,\n    BeforeObfuscation: TObfuscationEvent\n} = {\n    AfterObfuscation: 'afterObfuscation',\n    BeforeObfuscation: 'beforeObfuscation'\n};\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/enums/ObfuscationEvents.ts","export enum ObfuscationReplacers {\n    BooleanReplacer,\n    IdentifierReplacer,\n    NumberLiteralReplacer,\n    StringLiteralReplacer\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/enums/container/ObfuscationReplacers.ts","import 'reflect-metadata';\n\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport { TInputOptions } from './types/options/TInputOptions';\n\nimport { IInversifyContainerFacade } from './interfaces/container/IInversifyContainerFacade';\nimport { IJavaScriptObfuscator } from './interfaces/IJavaScriptObfsucator';\nimport { IObfuscationResult } from './interfaces/IObfuscationResult';\nimport { IOptions } from './interfaces/options/IOptions';\n\nimport { InversifyContainerFacade } from './container/InversifyContainerFacade';\nimport { JavaScriptObfuscatorCLI } from './cli/JavaScriptObfuscatorCLI';\nimport { RandomGeneratorUtils } from './utils/RandomGeneratorUtils';\n\nexport class JavaScriptObfuscator {\n    /**\n     * @param sourceCode\n     * @param inputOptions\n     * @returns {string}\n     */\n    public static obfuscate (sourceCode: string, inputOptions: TInputOptions = {}): IObfuscationResult {\n        const inversifyContainerFacade: IInversifyContainerFacade = new InversifyContainerFacade(inputOptions);\n        const options: IOptions = inversifyContainerFacade.get<IOptions>(ServiceIdentifiers.IOptions);\n\n        RandomGeneratorUtils.initializeRandomGenerator(options.seed);\n\n        const javaScriptObfuscator: IJavaScriptObfuscator = inversifyContainerFacade\n            .get<IJavaScriptObfuscator>(ServiceIdentifiers.IJavaScriptObfuscator);\n        const obfuscationResult: IObfuscationResult = javaScriptObfuscator.obfuscate(sourceCode);\n\n        RandomGeneratorUtils.clearRandomGenerator();\n\n        return obfuscationResult;\n    }\n\n    /**\n     * @param argv\n     */\n    public static runCLI (argv: string[]): void {\n        new JavaScriptObfuscatorCLI(argv).run();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/JavaScriptObfuscator.ts","import * as ESTree from 'estree';\n\nimport { TNodeWithBlockStatement } from '../types/node/TNodeWithBlockStatement';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { IStackTraceData } from '../interfaces/stack-trace-analyzer/IStackTraceData';\n\nimport { RandomGeneratorUtils } from '../utils/RandomGeneratorUtils';\n\n/**\n * This class appends node into a first deepest BlockStatement in order of function calls\n *\n * For example:\n *\n * function Foo () {\n *     var baz = function () {\n *\n *     }\n *\n *     baz();\n * }\n *\n * foo();\n *\n * Appends node into block statement of `baz` function expression.\n */\nexport class NodeAppender {\n    /**\n     * @param blockScopeNode\n     * @param nodeBodyStatements\n     */\n    public static appendNode (\n        blockScopeNode: TNodeWithBlockStatement,\n        nodeBodyStatements: TStatement[]\n    ): void {\n        if (!NodeAppender.validateBodyStatements(nodeBodyStatements)) {\n            nodeBodyStatements = [];\n        }\n\n        nodeBodyStatements = NodeAppender.parentizeBodyStatementsBeforeAppend(blockScopeNode, nodeBodyStatements);\n\n        blockScopeNode.body = [\n            ...blockScopeNode.body,\n            ...nodeBodyStatements\n        ];\n    }\n\n    /**\n     * @param blockScopeStackTraceData\n     * @param blockScopeNode\n     * @param nodeBodyStatements\n     * @param index\n     */\n    public static appendNodeToOptimalBlockScope (\n        blockScopeStackTraceData: IStackTraceData[],\n        blockScopeNode: TNodeWithBlockStatement,\n        nodeBodyStatements: TStatement[],\n        index: number = 0\n    ): void {\n        let targetBlockScope: TNodeWithBlockStatement;\n\n        if (!blockScopeStackTraceData.length) {\n            targetBlockScope = blockScopeNode;\n        } else {\n            targetBlockScope = NodeAppender.getOptimalBlockScope(\n                blockScopeStackTraceData,\n                index\n            );\n        }\n\n        NodeAppender.prependNode(targetBlockScope, nodeBodyStatements);\n    }\n\n    /**\n     * Returns deepest block scope node at given deep.\n     *\n     * @param blockScopeTraceData\n     * @param index\n     * @param deep\n     * @returns {ESTree.BlockStatement}\n     */\n    public static getOptimalBlockScope (\n        blockScopeTraceData: IStackTraceData[],\n        index: number,\n        deep: number = Infinity\n    ): ESTree.BlockStatement {\n        const firstCall: IStackTraceData = blockScopeTraceData[index];\n\n        if (deep <= 0) {\n            throw new Error(`Invalid \\`deep\\` argument value. Value should be bigger then 0.`);\n        }\n\n        if (deep > 1 && firstCall.stackTrace.length) {\n            return NodeAppender.getOptimalBlockScope(firstCall.stackTrace, 0, --deep);\n        } else {\n            return firstCall.callee;\n        }\n    }\n\n    /**\n     * @param stackTraceRootLength\n     */\n    public static getRandomStackTraceIndex (stackTraceRootLength: number): number {\n        return RandomGeneratorUtils.getRandomInteger(0, Math.max(0, Math.round(stackTraceRootLength - 1)));\n    }\n\n    /**\n     * @param blockScopeNode\n     * @param nodeBodyStatements\n     * @param index\n     */\n    public static insertNodeAtIndex (\n        blockScopeNode: TNodeWithBlockStatement,\n        nodeBodyStatements: TStatement[],\n        index: number\n    ): void {\n        if (!NodeAppender.validateBodyStatements(nodeBodyStatements)) {\n            nodeBodyStatements = [];\n        }\n\n        nodeBodyStatements = NodeAppender.parentizeBodyStatementsBeforeAppend(blockScopeNode, nodeBodyStatements);\n\n        blockScopeNode.body = [\n            ...blockScopeNode.body.slice(0, index),\n            ...nodeBodyStatements,\n            ...blockScopeNode.body.slice(index)\n        ];\n    }\n\n    /**\n     * @param blockScopeNode\n     * @param nodeBodyStatements\n     */\n    public static prependNode (\n        blockScopeNode: TNodeWithBlockStatement,\n        nodeBodyStatements: TStatement[]\n    ): void {\n        if (!NodeAppender.validateBodyStatements(nodeBodyStatements)) {\n            nodeBodyStatements = [];\n        }\n\n        nodeBodyStatements = NodeAppender.parentizeBodyStatementsBeforeAppend(blockScopeNode, nodeBodyStatements);\n\n        blockScopeNode.body = [\n            ...nodeBodyStatements,\n            ...blockScopeNode.body,\n        ];\n    }\n\n    /**\n     * @param blockScopeNode\n     * @param nodeBodyStatements\n     */\n    private static parentizeBodyStatementsBeforeAppend (\n        blockScopeNode: TNodeWithBlockStatement,\n        nodeBodyStatements: TStatement[]\n    ): TStatement[] {\n        nodeBodyStatements.forEach((statement: TStatement) => {\n            statement.parentNode = blockScopeNode;\n        });\n\n        return nodeBodyStatements;\n    }\n\n    /**\n     * @param nodeBodyStatements\n     * @returns {boolean}\n     */\n    private static validateBodyStatements (nodeBodyStatements: TStatement[]): boolean {\n        return nodeBodyStatements.every((statementNode: TStatement) => {\n            return !!statementNode && statementNode.hasOwnProperty('type');\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node/NodeAppender.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TNodeWithBlockStatement } from '../types/node/TNodeWithBlockStatement';\nimport { TObfuscationEvent } from '../types/event-emitters/TObfuscationEvent';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { ICustomNodeGroup } from '../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IStackTraceData } from '../interfaces/stack-trace-analyzer/IStackTraceData';\n\nimport { CustomNodes } from '../enums/container/CustomNodes';\n\n@injectable()\nexport abstract class AbstractCustomNodeGroup implements ICustomNodeGroup {\n    /**\n     * @type {TObfuscationEvent}\n     */\n    protected abstract readonly appendEvent: TObfuscationEvent;\n\n    /**\n     * @type {Map<CustomNodes, ICustomNode>}\n     */\n    protected abstract customNodes: Map <CustomNodes, ICustomNode>;\n\n    /**\n     * @type {IStackTraceData[]}\n     */\n    protected readonly stackTraceData: IStackTraceData[];\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @param blockScopeNode\n     * @param stackTraceData\n     */\n    public abstract appendCustomNodes (blockScopeNode: TNodeWithBlockStatement, stackTraceData: IStackTraceData[]): void;\n\n    /**\n     * @returns {TObfuscationEvent}\n     */\n    public getAppendEvent (): TObfuscationEvent {\n        return this.appendEvent;\n    }\n\n    /**\n     * @returns {Map<CustomNodes, ICustomNode>}\n     */\n    public getCustomNodes (): Map <CustomNodes, ICustomNode> {\n        return this.customNodes;\n    }\n\n    public abstract initialize (): void;\n\n    /**\n     * @param customNodeName\n     * @param callback\n     */\n    protected appendCustomNodeIfExist (customNodeName: CustomNodes, callback: (customNode: ICustomNode) => void): void {\n        const customNode: ICustomNode | undefined = this.customNodes.get(customNodeName);\n\n        if (!customNode) {\n            return;\n        }\n\n        callback(customNode);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/AbstractCustomNodeGroup.ts","module.exports = require(\"escodegen-wallaby\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"escodegen-wallaby\"\n// module id = 20\n// module chunks = 0","export const SourceMapMode: any = {\n    Inline: 'inline',\n    Separate: 'separate'\n};\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/enums/SourceMapMode.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IObfuscationReplacer } from '../../../interfaces/node-transformers/IObfuscationReplacer';\n\n@injectable()\nexport abstract class AbstractReplacer implements IObfuscationReplacer {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @param nodeValue\n     * @param nodeIdentifier\n     * @returns {string}\n     */\n    public abstract replace (nodeValue: any, nodeIdentifier?: number): string;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/obfuscating-transformers/replacers/AbstractReplacer.ts","import { TInputOptions } from '../../types/options/TInputOptions';\n\nimport { SourceMapMode } from '../../enums/SourceMapMode';\n\nexport const NO_CUSTOM_NODES_PRESET: TInputOptions = Object.freeze({\n    compact: true,\n    controlFlowFlattening: false,\n    controlFlowFlatteningThreshold: 0,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: false,\n    domainLock: [],\n    reservedNames: [],\n    rotateStringArray: false,\n    seed: 0,\n    selfDefending: false,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    stringArray: false,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0,\n    unicodeEscapeSequence: true\n});\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/options/presets/NoCustomNodes.ts","export const StringArrayEncoding: any = {\n    base64: 'base64',\n    rc4: 'rc4'\n};\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/enums/StringArrayEncoding.ts","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../interfaces/stack-trace-analyzer/ICalleeData';\nimport { ICalleeDataExtractor } from '../../interfaces/stack-trace-analyzer/ICalleeDataExtractor';\n\n@injectable()\nexport abstract class AbstractCalleeDataExtractor implements ICalleeDataExtractor {\n    /**\n     * @param blockScopeBody\n     * @param callee\n     * @returns {ICalleeData|null}\n     */\n    public abstract extract (blockScopeBody: ESTree.Node[], callee: ESTree.Node): ICalleeData|null;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/stack-trace-analyzer/callee-data-extractors/AbstractCalleeDataExtractor.ts","import { RandomGeneratorUtils } from './RandomGeneratorUtils';\nimport { Utils } from './Utils';\n\nexport class CryptUtils {\n    /**\n     * @param string\n     */\n    /* tslint:disable */\n    public static btoa (string: string): string {\n        const chars: string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n        let output: string = '';\n\n        string = encodeURIComponent(string).replace(/%([0-9A-F]{2})/g, (match, p1) => {\n            return String.fromCharCode(parseInt(`${Utils.hexadecimalPrefix}${p1}`));\n        });\n\n        for (\n            let block: number|undefined, charCode: number, idx: number = 0, map: string = chars;\n            string.charAt(idx | 0) || (map = '=', idx % 1);\n            output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n        ) {\n            charCode = string.charCodeAt(idx += 3/4);\n\n            if (charCode > 0xFF) {\n                throw new Error(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n            }\n\n            block = <number>block << 8 | charCode;\n        }\n\n        return output;\n    }\n    /* tslint:enable */\n\n    /**\n     * @param str\n     * @param length\n     * @returns {string[]}\n     */\n    public static hideString (str: string, length: number): [string, string] {\n        const escapeRegExp: (s: string) => string = (s: string) =>\n            s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\n        const randomMerge: (s1: string, s2: string) => string = function (s1: string, s2: string): string {\n            let i1: number = -1,\n                i2: number = -1,\n                result: string = '';\n\n            while (i1 < s1.length || i2 < s2.length) {\n                if (RandomGeneratorUtils.getMathRandom() < 0.5 && i2 < s2.length) {\n                    result += s2.charAt(++i2);\n                } else {\n                    result += s1.charAt(++i1);\n                }\n            }\n\n            return result;\n        };\n\n        const randomString: string = RandomGeneratorUtils.getRandomGenerator().string({\n            length: length,\n            pool: RandomGeneratorUtils.randomGeneratorPool\n        });\n\n        let randomStringDiff: string = randomString.replace(\n            new RegExp('[' + escapeRegExp(str) + ']', 'g'),\n            '');\n\n        const randomStringDiffArray: string[] = randomStringDiff.split('');\n\n        RandomGeneratorUtils.getRandomGenerator().shuffle(randomStringDiffArray);\n        randomStringDiff = randomStringDiffArray.join('');\n\n        return [randomMerge(str, randomStringDiff), randomStringDiff];\n\n    }\n\n    /**\n     * RC4 symmetric cipher encryption/decryption\n     * https://gist.github.com/farhadi/2185197\n     *\n     * @param key\n     * @param string\n     * @returns {string}\n     */\n    /* tslint:disable */\n    public static rc4 (string: string, key: string): string {\n        let s: number[] = [],\n            j: number = 0,\n            x: number,\n            result: string = '';\n\n        for (var i = 0; i < 256; i++) {\n            s[i] = i;\n        }\n\n        for (i = 0; i < 256; i++) {\n            j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n        }\n\n        i = 0;\n        j = 0;\n\n        for (let y = 0; y < string.length; y++) {\n            i = (i + 1) % 256;\n            j = (j + s[i]) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n            result += String.fromCharCode(string.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n        }\n\n        return result;\n    }\n    /* tslint:enable */\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/utils/CryptUtils.ts","export const JSFuck: any = {\n    False: '![]',\n    True: '!![]',\n\n    a: '(false+\"\")[1]',\n    b: '([][\"entries\"]()+\"\")[2]',\n    c: '([][\"fill\"]+\"\")[3]',\n    d: '(undefined+\"\")[2]',\n    e: '(true+\"\")[3]',\n    f: '(false+\"\")[0]',\n    g: '(false+[0]+String)[20]',\n    h: '(+(101))[\"toString\"](21)[1]',\n    i: '([false]+undefined)[10]',\n    j: '([][\"entries\"]()+\"\")[3]',\n    k: '(+(20))[\"toString\"](21)',\n    l: '(false+\"\")[2]',\n    m: '(Number+\"\")[11]',\n    n: '(undefined+\"\")[1]',\n    o: '(true+[][\"fill\"])[10]',\n    p: '(+(211))[\"toString\"](31)[1]',\n    q: '(+(212))[\"toString\"](31)[1]',\n    r: '(true+\"\")[1]',\n    s: '(false+\"\")[3]',\n    t: '(true+\"\")[0]',\n    u: '(undefined+\"\")[0]',\n    v: '(+(31))[\"toString\"](32)',\n    w: '(+(32))[\"toString\"](33)',\n    x: '(+(101))[\"toString\"](34)[1]',\n    y: '(NaN+[Infinity])[10]',\n    z: '(+(35))[\"toString\"](36)',\n\n    A: '(+[]+Array)[10]',\n    B: '(+[]+Boolean)[10]',\n    C: 'Function(\"return escape\")()((\"\")[\"italics\"]())[2]',\n    D: 'Function(\"return escape\")()([][\"fill\"])[\"slice\"](\"-1\")',\n    E: '(RegExp+\"\")[12]',\n    F: '(+[]+Function)[10]',\n    G: '(false+Function(\"return Date\")()())[30]',\n    H: `'H'`,\n    I: '(Infinity+\"\")[0]',\n    J: `'J'`,\n    K: `'K'`,\n    L: `'L'`,\n    M: '(true+Function(\"return Date\")()())[30]',\n    N: '(NaN+\"\")[0]',\n    O: '(NaN+Function(\"return{}\")())[11]',\n    P: `'P'`,\n    Q: `'Q'`,\n    R: '(+[]+RegExp)[10]',\n    S: '(+[]+String)[10]',\n    T: '(NaN+Function(\"return Date\")()())[30]',\n    U: '(NaN+Function(\"return{}\")()[\"toString\"][\"call\"]())[11]',\n    V: `'V'`,\n    W: `'W'`,\n    X: `'X'`,\n    Y: `'Y'`,\n    Z: `'Z'`\n};\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/enums/JSFuck.ts","export enum CalleeDataExtractors {\n    FunctionDeclarationCalleeDataExtractor,\n    FunctionExpressionCalleeDataExtractor,\n    ObjectExpressionCalleeDataExtractor,\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/enums/container/CalleeDataExtractors.ts","export enum ControlFlowReplacers {\n    BinaryExpressionControlFlowReplacer,\n    CallExpressionControlFlowReplacer,\n    LogicalExpressionControlFlowReplacer\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/enums/container/ControlFlowReplacers.ts","export enum CustomNodeGroups {\n    ConsoleOutputCustomNodeGroup,\n    DebugProtectionCustomNodeGroup,\n    DomainLockCustomNodeGroup,\n    SelfDefendingCustomNodeGroup,\n    StringArrayCustomNodeGroup\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/enums/container/CustomNodeGroups.ts","export enum NodeTransformers {\n    BlockStatementControlFlowTransformer,\n    FunctionControlFlowTransformer,\n    CatchClauseTransformer,\n    FunctionDeclarationTransformer,\n    FunctionTransformer,\n    LabeledStatementTransformer,\n    LiteralTransformer,\n    MemberExpressionTransformer,\n    MethodDefinitionTransformer,\n    ObjectExpressionTransformer,\n    TemplateLiteralTransformer,\n    VariableDeclarationTransformer\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/enums/container/NodeTransformers.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TCustomNodeFactory } from '../../../types/container/TCustomNodeFactory';\n\nimport { IControlFlowReplacer } from '../../../interfaces/node-transformers/IControlFlowReplacer';\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IStorage } from '../../../interfaces/storages/IStorage';\n\nimport { RandomGeneratorUtils } from '../../../utils/RandomGeneratorUtils';\n\n@injectable()\nexport abstract class AbstractControlFlowReplacer implements IControlFlowReplacer {\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    protected readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {Map<string, Map<string, string[]>>}\n     */\n    protected readonly replacerDataByControlFlowStorageId: Map <string, Map<string, string[]>> = new Map();\n\n    /**\n     * @param customNodeFactory\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.customNodeFactory = customNodeFactory;\n        this.options = options;\n    }\n\n    /**\n     * @param identifierDataByControlFlowStorageId\n     * @param controlFlowStorageId\n     * @returns {Map<string, string[]>}\n     */\n    protected static getStorageKeysByIdForCurrentStorage (\n        identifierDataByControlFlowStorageId: Map<string, Map<string, string[]>>,\n        controlFlowStorageId: string\n    ): Map<string, string[]> {\n        let storageKeysById: Map<string, string[]>;\n\n        if (identifierDataByControlFlowStorageId.has(controlFlowStorageId)) {\n            storageKeysById = <Map<string, string[]>>identifierDataByControlFlowStorageId.get(controlFlowStorageId);\n        } else {\n            storageKeysById = new Map <string, string[]> ();\n        }\n\n        return storageKeysById;\n    }\n\n    /**\n     * @param node\n     * @param parentNode\n     * @param controlFlowStorage\n     * @returns {ESTree.Node}\n     */\n    public abstract replace (node: ESTree.Node, parentNode: ESTree.Node, controlFlowStorage: IStorage <ICustomNode>): ESTree.Node;\n\n    /**\n     * @param customNode\n     * @param controlFlowStorage\n     * @param replacerId\n     * @param usingExistingIdentifierChance\n     * @returns {string}\n     */\n    protected insertCustomNodeToControlFlowStorage (\n        customNode: ICustomNode,\n        controlFlowStorage: IStorage <ICustomNode>,\n        replacerId: string,\n        usingExistingIdentifierChance: number\n    ): string {\n        const controlFlowStorageId: string = controlFlowStorage.getStorageId();\n        const storageKeysById: Map<string, string[]> = AbstractControlFlowReplacer\n            .getStorageKeysByIdForCurrentStorage(this.replacerDataByControlFlowStorageId, controlFlowStorageId);\n        const storageKeysForCurrentId: string[] | undefined = storageKeysById.get(replacerId);\n\n        if (\n            RandomGeneratorUtils.getMathRandom() > usingExistingIdentifierChance &&\n            storageKeysForCurrentId &&\n            storageKeysForCurrentId.length\n        ) {\n            return RandomGeneratorUtils.getRandomGenerator().pickone(storageKeysForCurrentId);\n        }\n\n        const generateStorageKey: (length: number) => string = (length: number) => {\n            const storageKey: string = RandomGeneratorUtils.getRandomString(length);\n\n            if (controlFlowStorage.getStorage().has(storageKey)) {\n                return generateStorageKey(length);\n            }\n\n            return storageKey;\n        };\n        const storageKey: string = generateStorageKey(3);\n\n        storageKeysById.set(replacerId, [storageKey]);\n        this.replacerDataByControlFlowStorageId.set(controlFlowStorageId, storageKeysById);\n        controlFlowStorage.set(storageKey, customNode);\n\n        return storageKey;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/control-flow-transformers/control-flow-replacers/AbstractControlFlowReplacer.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TCustomNodeFactory } from '../../../types/container/TCustomNodeFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { CustomNodes } from '../../../enums/container/CustomNodes';\nimport { Node } from '../../../node/Node';\n\n@injectable()\nexport abstract class ExpressionWithOperatorControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    protected readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {Map<string, Map<string, string[]>>}\n     */\n    protected readonly replacerDataByControlFlowStorageId: Map <string, Map<string, string[]>> = new Map();\n\n    /**\n     * @param customNodeFactory\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(customNodeFactory, options);\n    }\n\n    /**\n     * @param controlFlowStorageId\n     * @param storageKey\n     * @param leftExpression\n     * @param rightExpression\n     * @returns {ESTree.Node}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string,\n        leftExpression: ESTree.Expression,\n        rightExpression: ESTree.Expression\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.customNodeFactory(\n            CustomNodes.ExpressionWithOperatorControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey, leftExpression, rightExpression);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !Node.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/control-flow-transformers/control-flow-replacers/ExpressionWithOperatorControlFlowReplacer.ts","import { TInputOptions } from '../../types/options/TInputOptions';\n\nimport { SourceMapMode } from '../../enums/SourceMapMode';\n\nexport const DEFAULT_PRESET: TInputOptions = Object.freeze({\n    compact: true,\n    controlFlowFlattening: false,\n    controlFlowFlatteningThreshold: 0.75,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: true,\n    domainLock: [],\n    reservedNames: [],\n    rotateStringArray: true,\n    seed: 0,\n    selfDefending: false,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    stringArray: true,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0.8,\n    unicodeEscapeSequence: true\n});\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/options/presets/Default.ts","import { injectable } from 'inversify';\n\nimport { IStorage } from '../interfaces/storages/IStorage';\n\nimport { initializable } from '../decorators/Initializable';\n\nimport { RandomGeneratorUtils } from '../utils/RandomGeneratorUtils';\n\n@injectable()\nexport abstract class MapStorage <T> implements IStorage <T> {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected storageId: string;\n\n    /**\n     * @type {Map <string | number, T>}\n     */\n    @initializable()\n    protected storage: Map <string | number, T>;\n\n    /**\n     * @param key\n     * @returns {T}\n     */\n    public get (key: string | number): T {\n        const value: T | undefined = this.storage.get(key);\n\n        if (!value) {\n            throw new Error(`No value found in map storage with key \\`${key}\\``);\n        }\n\n        return value;\n    }\n\n    /**\n     * @param value\n     * @returns {string | number | null}\n     */\n    public getKeyOf (value: T): string | number | null {\n        for (const [key, storageValue] of this.storage) {\n            if (value === storageValue) {\n                return key;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getLength (): number {\n        return this.storage.size;\n    }\n\n    /**\n     * @returns {Map <string | number, T>}\n     */\n    public getStorage (): Map <string | number, T> {\n        return this.storage;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageId (): string {\n        return this.storageId;\n    }\n\n    /**\n     * @param args\n     */\n    public initialize (...args: any[]): void {\n        this.storage = new Map <string | number, T> ();\n        this.storageId = RandomGeneratorUtils.getRandomString(6);\n    }\n\n    /**\n     * @param storage\n     * @param mergeId\n     */\n    public mergeWith (storage: this, mergeId: boolean = false): void {\n        this.storage = new Map <string | number, T> ([...this.storage, ...storage.getStorage()]);\n\n        if (mergeId) {\n            this.storageId = storage.getStorageId();\n        }\n    }\n\n    /**\n     * @param key\n     * @param value\n     */\n    public set (key: string | number, value: T): void {\n        this.storage.set(key, value);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/storages/MapStorage.ts","module.exports = require(\"esprima\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"esprima\"\n// module id = 36\n// module chunks = 0","module.exports = require(\"path\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"path\"\n// module id = 37\n// module chunks = 0","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport * as esprima from 'esprima';\nimport * as escodegen from 'escodegen-wallaby';\nimport * as ESTree from 'estree';\n\nimport { IGeneratorOutput } from './interfaces/IGeneratorOutput';\nimport { IJavaScriptObfuscator } from './interfaces/IJavaScriptObfsucator';\nimport { IObfuscationResult } from './interfaces/IObfuscationResult';\nimport { IObfuscator } from './interfaces/IObfuscator';\nimport { IOptions } from './interfaces/options/IOptions';\nimport { ISourceMapCorrector } from './interfaces/ISourceMapCorrector';\n\n@injectable()\nexport class JavaScriptObfuscatorInternal implements IJavaScriptObfuscator {\n    /**\n     * @type {GenerateOptions}\n     */\n    private static readonly escodegenParams: escodegen.GenerateOptions = {\n        verbatim: 'x-verbatim-property',\n        sourceMapWithCode: true\n    };\n\n    /**\n     * @type {IObfuscator}\n     */\n    private readonly obfuscator: IObfuscator;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {ISourceMapCorrector}\n     */\n    private readonly sourceMapCorrector: ISourceMapCorrector;\n\n    /**\n     * @param obfuscator\n     * @param sourceMapCorrector\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IObfuscator) obfuscator: IObfuscator,\n        @inject(ServiceIdentifiers.ISourceMapCorrector) sourceMapCorrector: ISourceMapCorrector,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.obfuscator = obfuscator;\n        this.sourceMapCorrector = sourceMapCorrector;\n        this.options = options;\n    }\n\n    /**\n     * @param sourceCode\n     * @returns {IObfuscationResult}\n     */\n    public obfuscate (sourceCode: string): IObfuscationResult {\n        // parse AST tree\n        const astTree: ESTree.Program = esprima.parse(sourceCode, { loc: this.options.sourceMap });\n\n        // obfuscate AST tree\n        const obfuscatedAstTree: ESTree.Program = this.obfuscator.obfuscateAstTree(astTree);\n\n        // generate code\n        const generatorOutput: IGeneratorOutput = this.generateCode(sourceCode, obfuscatedAstTree);\n\n        return this.getObfuscationResult(generatorOutput);\n    }\n\n    /**\n     * @param sourceCode\n     * @param astTree\n     */\n    private generateCode (sourceCode: string, astTree: ESTree.Program): IGeneratorOutput {\n        const escodegenParams: escodegen.GenerateOptions = {\n            ...JavaScriptObfuscatorInternal.escodegenParams\n        };\n\n        if (this.options.sourceMap) {\n            escodegenParams.sourceMap = 'sourceMap';\n            escodegenParams.sourceContent = sourceCode;\n        }\n\n        escodegenParams.format = {\n            compact: this.options.compact\n        };\n\n        const generatorOutput: IGeneratorOutput = escodegen.generate(astTree, escodegenParams);\n\n        generatorOutput.map = generatorOutput.map ? generatorOutput.map.toString() : '';\n\n        return generatorOutput;\n    }\n\n    /**\n     * @param generatorOutput\n     * @returns {IObfuscationResult}\n     */\n    private getObfuscationResult (generatorOutput: IGeneratorOutput): IObfuscationResult {\n        return this.sourceMapCorrector.correct(\n            generatorOutput.code,\n            generatorOutput.map\n        );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/JavaScriptObfuscatorInternal.ts","import { injectable } from 'inversify';\n\nimport { IObfuscationResult } from './interfaces/IObfuscationResult';\n\nimport { initializable } from './decorators/Initializable';\n\n@injectable()\nexport class ObfuscationResult implements IObfuscationResult {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private obfuscatedCode: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private sourceMap: string;\n\n    /**\n     * @param obfuscatedCode\n     * @param sourceMap\n     */\n    public initialize (obfuscatedCode: string, sourceMap: string): void {\n        this.obfuscatedCode = obfuscatedCode;\n        this.sourceMap = sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getObfuscatedCode (): string {\n        return this.obfuscatedCode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceMap (): string {\n        return this.sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.obfuscatedCode;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/ObfuscationResult.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeTransformerFactory } from './types/container/TNodeTransformerFactory';\nimport { TVisitorDirection } from './types/TVisitorDirection';\nimport { TVisitorFunction } from './types/TVisitorFunction';\n\nimport { ICustomNodeGroup } from './interfaces/custom-nodes/ICustomNodeGroup';\nimport { IObfuscationEventEmitter } from './interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IObfuscator } from './interfaces/IObfuscator';\nimport { IOptions } from './interfaces/options/IOptions';\nimport { IStackTraceAnalyzer } from './interfaces/stack-trace-analyzer/IStackTraceAnalyzer';\nimport { IStackTraceData } from './interfaces/stack-trace-analyzer/IStackTraceData';\nimport { IStorage } from './interfaces/storages/IStorage';\nimport { IVisitor } from './interfaces/IVisitor';\n\nimport { NodeTransformers } from './enums/container/NodeTransformers';\nimport { ObfuscationEvents } from './enums/ObfuscationEvents';\nimport { VisitorDirection } from './enums/VisitorDirection';\n\nimport { Node } from './node/Node';\nimport { NodeUtils } from './node/NodeUtils';\n\n@injectable()\nexport class Obfuscator implements IObfuscator {\n    /**\n     * @type {NodeTransformers[]}\n     */\n    private static readonly controlFlowTransformersList: NodeTransformers[] = [\n        NodeTransformers.BlockStatementControlFlowTransformer,\n        NodeTransformers.FunctionControlFlowTransformer\n    ];\n\n    /**\n     * @type {NodeTransformers[]}\n     */\n    private static readonly convertingTransformersList: NodeTransformers[] = [\n        NodeTransformers.MemberExpressionTransformer,\n        NodeTransformers.MethodDefinitionTransformer,\n        NodeTransformers.TemplateLiteralTransformer\n    ];\n\n    /**\n     * @type {NodeTransformers[]}\n     */\n    private static readonly obfuscatingTransformersList: NodeTransformers[] = [\n        NodeTransformers.CatchClauseTransformer,\n        NodeTransformers.FunctionDeclarationTransformer,\n        NodeTransformers.FunctionTransformer,\n        NodeTransformers.LabeledStatementTransformer,\n        NodeTransformers.LiteralTransformer,\n        NodeTransformers.ObjectExpressionTransformer,\n        NodeTransformers.VariableDeclarationTransformer\n    ];\n\n    /**\n     * @type {IStorage<ICustomNodeGroup>}\n     */\n    private readonly customNodeGroupStorage: IStorage<ICustomNodeGroup>;\n\n    /**\n     * @type {TNodeTransformerFactory}\n     */\n    private readonly nodeTransformerFactory: TNodeTransformerFactory;\n\n    /**\n     * @type {IObfuscationEventEmitter}\n     */\n    private readonly obfuscationEventEmitter: IObfuscationEventEmitter;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {IStackTraceAnalyzer}\n     */\n    private readonly stackTraceAnalyzer: IStackTraceAnalyzer;\n\n    /**\n     * @param stackTraceAnalyzer\n     * @param obfuscationEventEmitter\n     * @param customNodeGroupStorage\n     * @param nodeTransformerFactory\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IStackTraceAnalyzer) stackTraceAnalyzer: IStackTraceAnalyzer,\n        @inject(ServiceIdentifiers.IObfuscationEventEmitter) obfuscationEventEmitter: IObfuscationEventEmitter,\n        @inject(ServiceIdentifiers.TCustomNodeGroupStorage) customNodeGroupStorage: IStorage<ICustomNodeGroup>,\n        @inject(ServiceIdentifiers.Factory__INodeTransformer) nodeTransformerFactory: TNodeTransformerFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.stackTraceAnalyzer = stackTraceAnalyzer;\n        this.obfuscationEventEmitter = obfuscationEventEmitter;\n        this.customNodeGroupStorage = customNodeGroupStorage;\n        this.nodeTransformerFactory = nodeTransformerFactory;\n        this.options = options;\n    }\n\n    /**\n     * @param astTree\n     * @returns {ESTree.Program}\n     */\n    public obfuscateAstTree (astTree: ESTree.Program): ESTree.Program {\n        if (Node.isProgramNode(astTree) && !astTree.body.length) {\n            return astTree;\n        }\n\n        astTree = <ESTree.Program>NodeUtils.parentize(astTree);\n\n        const stackTraceData: IStackTraceData[] = this.stackTraceAnalyzer.analyze(astTree.body);\n\n        // initialize custom node groups and configure custom nodes\n        this.customNodeGroupStorage\n            .getStorage()\n            .forEach((customNodeGroup: ICustomNodeGroup) => {\n                customNodeGroup.initialize();\n\n                this.obfuscationEventEmitter.once(\n                    customNodeGroup.getAppendEvent(),\n                    customNodeGroup.appendCustomNodes.bind(customNodeGroup)\n                );\n            });\n\n        this.obfuscationEventEmitter.emit(ObfuscationEvents.BeforeObfuscation, astTree, stackTraceData);\n\n        // first pass: control flow flattening\n        if (this.options.controlFlowFlattening) {\n            astTree = this.transformAstTree(astTree, Obfuscator.controlFlowTransformersList);\n        }\n\n        // second pass: nodes obfuscation\n        astTree = this.transformAstTree(astTree, [\n            ...Obfuscator.convertingTransformersList,\n            ...Obfuscator.obfuscatingTransformersList\n        ]);\n\n        this.obfuscationEventEmitter.emit(ObfuscationEvents.AfterObfuscation, astTree, stackTraceData);\n\n        return astTree;\n    }\n\n    /**\n     * @param astTree\n     * @param nodeTransformers\n     */\n    private transformAstTree (\n        astTree: ESTree.Program,\n        nodeTransformers: NodeTransformers[]\n    ): ESTree.Program {\n        const enterVisitors: IVisitor[] = [];\n        const leaveVisitors: IVisitor[] = [];\n        const nodeTransformersLength: number = nodeTransformers.length;\n\n        let visitor: IVisitor;\n\n        for (let i: number = 0; i < nodeTransformersLength; i++) {\n            visitor = this.nodeTransformerFactory(nodeTransformers[i]).getVisitor();\n\n            if (visitor.enter) {\n                enterVisitors.push(visitor);\n            }\n\n            if (visitor.leave) {\n                leaveVisitors.push(visitor);\n            }\n        }\n\n        estraverse.replace(astTree, {\n            enter: this.mergeVisitorsForDirection(enterVisitors, VisitorDirection.enter),\n            leave: this.mergeVisitorsForDirection(leaveVisitors, VisitorDirection.leave)\n        });\n\n        return astTree;\n    }\n\n    /**\n     * @param visitors\n     * @param direction\n     * @return {TVisitorDirection}\n     */\n    private mergeVisitorsForDirection (visitors: IVisitor[], direction: TVisitorDirection): TVisitorFunction {\n        if (!visitors.length) {\n            return (node: ESTree.Node, parentNode: ESTree.Node) => node;\n        }\n\n        const visitorsLength: number = visitors.length;\n\n        let visitor: IVisitor;\n\n        return (node: ESTree.Node, parentNode: ESTree.Node) => {\n            for (let i: number = 0; i < visitorsLength; i++) {\n                visitor = visitors[i];\n\n                const visitorFunction: TVisitorFunction | undefined = visitor[direction];\n\n                if (!visitorFunction) {\n                    continue;\n                }\n\n                const visitorResult: ESTree.Node | void = visitorFunction(node, parentNode);\n\n                if (!visitorResult) {\n                    continue;\n                }\n\n                node = visitorResult;\n            }\n\n            return node;\n        };\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/Obfuscator.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport { TObfuscationResultFactory } from './types/container/TObfuscationResultFactory';\n\nimport { IObfuscationResult } from './interfaces/IObfuscationResult';\nimport { IOptions } from './interfaces/options/IOptions';\nimport { ISourceMapCorrector } from './interfaces/ISourceMapCorrector';\n\nimport { SourceMapMode } from './enums/SourceMapMode';\n\nimport { CryptUtils } from './utils/CryptUtils';\n\n@injectable()\nexport class SourceMapCorrector implements ISourceMapCorrector {\n    /**\n     * @type {TObfuscationResultFactory}\n     */\n    private readonly obfuscationResultFactory: TObfuscationResultFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @param obfuscationResultFactory\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IObfuscationResult) obfuscationResultFactory: TObfuscationResultFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.obfuscationResultFactory = obfuscationResultFactory;\n        this.options = options;\n    }\n\n    /**\n     * @returns {ObfuscationResult}\n     * @param obfuscatedCode\n     * @param sourceMap\n     */\n    public correct (obfuscatedCode: string, sourceMap: string): IObfuscationResult {\n        return this.obfuscationResultFactory(\n            this.correctObfuscatedCode(obfuscatedCode, sourceMap),\n            sourceMap\n        );\n    }\n\n    /**\n     * @param obfuscatedCode\n     * @param sourceMap\n     * @returns {string}\n     */\n    private correctObfuscatedCode (obfuscatedCode: string, sourceMap: string): string {\n        if (!sourceMap) {\n            return obfuscatedCode;\n        }\n\n        const sourceMapUrl: string = this.options.sourceMapBaseUrl + this.options.sourceMapFileName;\n\n        let sourceMappingUrl: string = '//# sourceMappingURL=';\n\n        switch (this.options.sourceMapMode) {\n            case SourceMapMode.Inline:\n                sourceMappingUrl += `data:application/json;base64,${CryptUtils.btoa(sourceMap)}`;\n\n                break;\n\n            case SourceMapMode.Separate:\n            default:\n                if (!sourceMapUrl) {\n                    return obfuscatedCode;\n                }\n\n                sourceMappingUrl += sourceMapUrl;\n\n                break;\n        }\n\n        return `${obfuscatedCode}\\n${sourceMappingUrl}`;\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/SourceMapCorrector.ts","import * as fs from 'fs';\nimport * as mkdirp from 'mkdirp';\nimport * as path from 'path';\n\nimport { IPackageConfig } from '../interfaces/IPackageConfig';\n\nexport class CLIUtils {\n    /**\n     * @type {string[]}\n     */\n    private static readonly availableInputExtensions: string[] = [\n        '.js'\n    ];\n\n    /**\n     * @type {BufferEncoding}\n     */\n    private static readonly encoding: BufferEncoding = 'utf8';\n\n    /**\n     * @param outputPath\n     * @param inputPath\n     * @returns {string}\n     */\n    public static getOutputCodePath (outputPath: string, inputPath: string): string {\n        if (outputPath) {\n            return outputPath;\n        }\n\n        return inputPath\n            .split('.')\n            .map<string>((value: string, index: number) => {\n                return index === 0 ? `${value}-obfuscated` : value;\n            })\n            .join('.');\n    }\n\n    /**\n     * @param outputCodePath\n     * @param sourceMapFileName\n     * @returns {string}\n     */\n    public static getOutputSourceMapPath (outputCodePath: string, sourceMapFileName: string = ''): string {\n        if (sourceMapFileName) {\n            outputCodePath = `${outputCodePath.substring(\n                0, outputCodePath.lastIndexOf('/')\n            )}/${sourceMapFileName}`;\n        }\n\n        if (!/\\.js\\.map$/.test(outputCodePath)) {\n            outputCodePath = `${outputCodePath.split('.')[0]}.js.map`;\n        } else if (/\\.js$/.test(outputCodePath)) {\n            outputCodePath += '.map';\n        }\n\n        return outputCodePath;\n    }\n\n    /**\n     * @returns {IPackageConfig}\n     */\n    public static getPackageConfig (): IPackageConfig {\n        return <IPackageConfig>JSON.parse(\n            fs.readFileSync(\n                path.join(\n                    path.dirname(\n                        fs.realpathSync(process.argv[1])\n                    ),\n                    '../package.json'\n                ),\n                CLIUtils.encoding\n            )\n        );\n    }\n\n    /**\n     * @param filePath\n     */\n    public static isFilePath (filePath: string): boolean {\n        try {\n            return fs.statSync(filePath).isFile();\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * @param inputPath\n     * @returns {string}\n     */\n    public static readFile (inputPath: string): string {\n        return fs.readFileSync(inputPath, CLIUtils.encoding);\n    }\n\n    /**\n     * @param inputPath\n     */\n    public static validateInputPath (inputPath: string): void {\n        if (!CLIUtils.isFilePath(inputPath)) {\n            throw new ReferenceError(`Given input path must be a valid file path`);\n        }\n\n        if (!CLIUtils.availableInputExtensions.includes(path.extname(inputPath))) {\n            throw new ReferenceError(`Input file must have .js extension`);\n        }\n    }\n\n    /**\n     * @param outputPath\n     * @param data\n     */\n    public static writeFile (outputPath: string, data: any): void {\n        mkdirp.sync(path.dirname(outputPath));\n\n        fs.writeFileSync(outputPath, data, {\n            encoding: CLIUtils.encoding\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/cli/CLIUtils.ts","import * as commander from 'commander';\nimport * as path from 'path';\n\nimport { TInputOptions } from '../types/options/TInputOptions';\nimport { TStringArrayEncoding } from '../types/options/TStringArrayEncoding';\n\nimport { IObfuscationResult } from '../interfaces/IObfuscationResult';\n\nimport { SourceMapMode } from '../enums/SourceMapMode';\nimport { StringArrayEncoding } from '../enums/StringArrayEncoding';\n\nimport { DEFAULT_PRESET } from '../options/presets/Default';\n\nimport { CLIUtils } from './CLIUtils';\nimport { JavaScriptObfuscator } from '../JavaScriptObfuscator';\n\nexport class JavaScriptObfuscatorCLI {\n    /**\n     * @type {string[]}\n     */\n    private readonly arguments: string[];\n\n    /**\n     * @type {commander.ICommand}\n     */\n    private commands: commander.ICommand;\n\n    /**\n     * @type {string}\n     */\n    private data: string = '';\n\n    /**\n     * @type {string}\n     */\n    private inputPath: string;\n\n    /**\n     * @type {string[]}\n     */\n    private rawArguments: string[];\n\n    /**\n     * @param argv\n     */\n    constructor (argv: string[]) {\n        this.rawArguments = argv;\n        this.arguments = this.rawArguments.slice(2);\n    }\n\n    /**\n     * @returns {string}\n     */\n    private static getBuildVersion (): string {\n        return CLIUtils.getPackageConfig().version;\n    }\n\n    /**\n     * @param value\n     * @returns {boolean}\n     */\n    private static parseBoolean (value: string): boolean {\n        return value === 'true' || value === '1';\n    }\n\n    /**\n     * @param value\n     * @returns {string}\n     */\n    private static parseSourceMapMode (value: string): string {\n        const availableMode: boolean = Object\n            .keys(SourceMapMode)\n            .some((key: string): boolean => {\n                return SourceMapMode[key] === value;\n            });\n\n        if (!availableMode) {\n            throw new ReferenceError('Invalid value of `--sourceMapMode` option');\n        }\n\n        return value;\n    }\n\n    /**\n     * @param value\n     * @returns {TStringArrayEncoding}\n     */\n    private static parseStringArrayEncoding (value: string): TStringArrayEncoding {\n        switch (value) {\n            case 'true':\n            case '1':\n            case StringArrayEncoding.base64:\n                return true;\n\n            case StringArrayEncoding.rc4:\n                return StringArrayEncoding.rc4;\n\n            default:\n                return false;\n        }\n    }\n\n    public run (): void {\n        this.configureCommands();\n\n        if (!this.arguments.length || this.arguments.includes('--help')) {\n            this.commands.outputHelp();\n\n            return;\n        }\n\n        this.inputPath = this.arguments[0];\n        CLIUtils.validateInputPath(this.inputPath);\n\n        this.getData();\n        this.processData();\n    }\n\n    /**\n     * @returns {TInputOptions}\n     */\n    private buildOptions (): TInputOptions {\n        const inputOptions: TInputOptions = {};\n        const availableOptions: string[] = Object.keys(DEFAULT_PRESET);\n\n        for (const option in this.commands) {\n            if (!this.commands.hasOwnProperty(option)) {\n                continue;\n            }\n\n            if (!availableOptions.includes(option)) {\n                continue;\n            }\n\n            (<any>inputOptions)[option] = (<any>this.commands)[option];\n        }\n\n        return {\n            ...DEFAULT_PRESET,\n            ...inputOptions\n        };\n    }\n\n    private configureCommands (): void {\n        this.commands = new commander.Command()\n            .version(JavaScriptObfuscatorCLI.getBuildVersion(), '-v, --version')\n            .usage('<inputPath> [options]')\n            .option(\n                '-o, --output <path>',\n                'Output path for obfuscated code'\n            )\n            .option(\n                '--compact <boolean>',\n                'Disable one line output code compacting',\n                JavaScriptObfuscatorCLI.parseBoolean\n            )\n            .option(\n                '--controlFlowFlattening <boolean>',\n                'Enables control flow flattening',\n                JavaScriptObfuscatorCLI.parseBoolean\n            )\n            .option(\n                '--controlFlowFlatteningThreshold <number>',\n                'The probability that the control flow flattening transformation will be applied to the node',\n                parseFloat\n            )\n            .option(\n                '--debugProtection <boolean>',\n                'Disable browser Debug panel (can cause DevTools enabled browser freeze)',\n                JavaScriptObfuscatorCLI.parseBoolean\n            )\n            .option(\n                '--debugProtectionInterval <boolean>',\n                'Disable browser Debug panel even after page was loaded (can cause DevTools enabled browser freeze)',\n                JavaScriptObfuscatorCLI.parseBoolean\n            )\n            .option(\n                '--disableConsoleOutput <boolean>',\n                'Allow console.log, console.info, console.error and console.warn messages output into browser console',\n                JavaScriptObfuscatorCLI.parseBoolean\n            )\n            .option(\n                '--domainLock <list>',\n                'Blocks the execution of the code in domains that do not match the passed RegExp patterns (comma separated)',\n                (value: string) => value.split(',')\n            )\n            .option(\n                '--reservedNames <list>',\n                'Disable obfuscation of variable names, function names and names of function parameters that match the passed RegExp patterns (comma separated)',\n                (value: string) => value.split(',')\n            )\n            .option(\n                '--rotateStringArray <boolean>', 'Disable rotation of unicode array values during obfuscation',\n                JavaScriptObfuscatorCLI.parseBoolean\n            )\n            .option(\n                '--seed <number>',\n                'Sets seed for random generator. This is useful for creating repeatable results.',\n                parseFloat\n            )\n            .option(\n                '--selfDefending <boolean>',\n                'Disables self-defending for obfuscated code',\n                JavaScriptObfuscatorCLI.parseBoolean\n            )\n            .option(\n                '--sourceMap <boolean>',\n                'Enables source map generation',\n                JavaScriptObfuscatorCLI.parseBoolean\n            )\n            .option(\n                '--sourceMapBaseUrl <string>',\n                'Sets base url to the source map import url when `--sourceMapMode=separate`'\n            )\n            .option(\n                '--sourceMapFileName <string>',\n                'Sets file name for output source map when `--sourceMapMode=separate`'\n            )\n            .option(\n                '--sourceMapMode <string> [inline, separate]',\n                'Specify source map output mode',\n                JavaScriptObfuscatorCLI.parseSourceMapMode\n            )\n            .option(\n                '--stringArray <boolean>',\n                'Disables gathering of all literal strings into an array and replacing every literal string with an array call',\n                JavaScriptObfuscatorCLI.parseBoolean\n            )\n            .option(\n                '--stringArrayEncoding <boolean|string> [true, false, base64, rc4]',\n                'Encodes all strings in strings array using base64 or rc4 (this option can slow down your code speed',\n                JavaScriptObfuscatorCLI.parseStringArrayEncoding\n            )\n            .option(\n                '--stringArrayThreshold <number>',\n                'The probability that the literal string will be inserted into stringArray (Default: 0.8, Min: 0, Max: 1)',\n                parseFloat\n            )\n            .option(\n                '--unicodeEscapeSequence <boolean>',\n                'Allows to enable/disable string conversion to unicode escape sequence',\n                JavaScriptObfuscatorCLI.parseBoolean\n            )\n            .parse(this.rawArguments);\n\n        this.commands.on('--help', () => {\n            console.log('  Examples:\\n');\n            console.log('    %> javascript-obfuscator in.js --compact true --selfDefending false');\n            console.log('    %> javascript-obfuscator in.js --output out.js --compact true --selfDefending false');\n            console.log('');\n        });\n    }\n\n    private getData (): void {\n        this.data = CLIUtils.readFile(this.inputPath);\n    }\n\n    private processData (): void {\n        const options: TInputOptions = this.buildOptions();\n        const outputCodePath: string = CLIUtils.getOutputCodePath((<any>this.commands).output, this.inputPath);\n\n        if (options.sourceMap) {\n            this.processDataWithSourceMap(outputCodePath, options);\n        } else {\n            this.processDataWithoutSourceMap(outputCodePath, options);\n        }\n    }\n\n    /**\n     * @param outputCodePath\n     * @param options\n     */\n    private processDataWithoutSourceMap (outputCodePath: string, options: TInputOptions): void {\n        const obfuscatedCode: string = JavaScriptObfuscator.obfuscate(this.data, options).getObfuscatedCode();\n\n        CLIUtils.writeFile(outputCodePath, obfuscatedCode);\n    }\n\n    /**\n     * @param outputCodePath\n     * @param options\n     */\n    private processDataWithSourceMap (outputCodePath: string, options: TInputOptions): void {\n        const outputSourceMapPath: string = CLIUtils.getOutputSourceMapPath(\n            outputCodePath,\n            options.sourceMapFileName || ''\n        );\n\n        options = {\n            ...options,\n            sourceMapFileName: path.basename(outputSourceMapPath)\n        };\n\n        const obfuscationResult: IObfuscationResult = JavaScriptObfuscator.obfuscate(this.data, options);\n\n        CLIUtils.writeFile(outputCodePath, obfuscationResult.getObfuscatedCode());\n\n        if (options.sourceMapMode === 'separate' && obfuscationResult.getSourceMap()) {\n            CLIUtils.writeFile(outputSourceMapPath, obfuscationResult.getSourceMap());\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/cli/JavaScriptObfuscatorCLI.ts","import { Container, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from './ServiceIdentifiers';\n\nimport { controlFlowTransformersModule } from './modules/node-transformers/ControlFlowTransformersModule';\nimport { customNodesModule } from './modules/custom-nodes/CustomNodesModule';\nimport { obfuscatingTransformersModule } from './modules/node-transformers/ObfuscatingTransformersModule';\nimport { nodeTransformersModule } from './modules/node-transformers/NodeTransformersModule';\nimport { stackTraceAnalyzerModule } from './modules/stack-trace-analyzer/StackTraceAnalyzerModule';\nimport { storagesModule } from './modules/storages/StoragesModule';\n\nimport { TInputOptions } from '../types/options/TInputOptions';\n\nimport { IInversifyContainerFacade } from '../interfaces/container/IInversifyContainerFacade';\nimport { IJavaScriptObfuscator } from '../interfaces/IJavaScriptObfsucator';\nimport { IObfuscationEventEmitter } from '../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IObfuscationResult } from '../interfaces/IObfuscationResult';\nimport { IObfuscator } from '../interfaces/IObfuscator';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { ISourceMapCorrector } from '../interfaces/ISourceMapCorrector';\n\nimport { JavaScriptObfuscatorInternal } from '../JavaScriptObfuscatorInternal';\nimport { ObfuscationEventEmitter } from '../event-emitters/ObfuscationEventEmitter';\nimport { ObfuscationResult } from '../ObfuscationResult';\nimport { Obfuscator } from '../Obfuscator';\nimport { Options } from \"../options/Options\";\nimport { SourceMapCorrector } from '../SourceMapCorrector';\n\nexport class InversifyContainerFacade implements IInversifyContainerFacade {\n    /**\n     * @type {interfaces.Container}\n     */\n    private readonly container: interfaces.Container;\n\n    /**\n     * @param options\n     */\n    constructor (options: TInputOptions) {\n        this.container = new Container();\n\n        this.container\n            .bind<IOptions>(ServiceIdentifiers.IOptions)\n            .toDynamicValue(() => {\n                return new Options(options);\n            })\n            .inSingletonScope();\n\n        this.container\n            .bind<IJavaScriptObfuscator>(ServiceIdentifiers.IJavaScriptObfuscator)\n            .to(JavaScriptObfuscatorInternal)\n            .inSingletonScope();\n\n        this.container\n            .bind<IObfuscator>(ServiceIdentifiers.IObfuscator)\n            .to(Obfuscator)\n            .inSingletonScope();\n\n        this.container\n            .bind<IObfuscationResult>(ServiceIdentifiers.IObfuscationResult)\n            .to(ObfuscationResult)\n            .inSingletonScope();\n\n        this.container\n            .bind<IObfuscationResult>(ServiceIdentifiers.Factory__IObfuscationResult)\n            .toFactory<IObfuscationResult>((context: interfaces.Context) => {\n                return (obfuscatedCode: string, sourceMap: string) => {\n                    const obfuscationResult: IObfuscationResult = context.container\n                        .get<IObfuscationResult>(ServiceIdentifiers.IObfuscationResult);\n\n                    obfuscationResult.initialize(obfuscatedCode, sourceMap);\n\n                    return obfuscationResult;\n                };\n            });\n\n        this.container\n            .bind<ISourceMapCorrector>(ServiceIdentifiers.ISourceMapCorrector)\n            .to(SourceMapCorrector)\n            .inSingletonScope();\n\n        this.container\n            .bind<IObfuscationEventEmitter>(ServiceIdentifiers.IObfuscationEventEmitter)\n            .to(ObfuscationEventEmitter)\n            .inSingletonScope();\n\n        // modules\n        this.container.load(storagesModule);\n        this.container.load(stackTraceAnalyzerModule);\n        this.container.load(customNodesModule);\n        this.container.load(nodeTransformersModule);\n        this.container.load(controlFlowTransformersModule);\n        this.container.load(obfuscatingTransformersModule);\n    }\n\n    /**\n     * @param serviceIdentifier\n     * @returns {T}\n     */\n    public get <T> (serviceIdentifier: interfaces.ServiceIdentifier<T>): T {\n        return this.container.get<T>(serviceIdentifier);\n    }\n\n    /**\n     * @param serviceIdentifier\n     * @param named\n     * @returns {T}\n     */\n    public getNamed <T> (serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): T {\n        return this.container.getNamed<T>(serviceIdentifier, named);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/container/InversifyContainerFacade.ts","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { ICustomNodeGroup } from '../../../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\nimport { CustomNodes } from '../../../enums/container/CustomNodes';\nimport { CustomNodeGroups } from '../../../enums/container/CustomNodeGroups';\n\nimport { ConsoleOutputCustomNodeGroup } from '../../../custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup';\nimport { DebugProtectionCustomNodeGroup } from '../../../custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup';\nimport { DomainLockCustomNodeGroup } from '../../../custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup';\nimport { SelfDefendingCustomNodeGroup } from '../../../custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup';\nimport { StringArrayCustomNodeGroup } from '../../../custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup';\n\nimport { BinaryExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode';\nimport { BlockStatementControlFlowFlatteningNode } from '../../../custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode';\nimport { CallExpressionControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode';\nimport { CallExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode';\nimport { ControlFlowStorageNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode';\nimport { ConsoleOutputDisableExpressionNode } from '../../../custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode';\nimport { DebugProtectionFunctionCallNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode';\nimport { DebugProtectionFunctionIntervalNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode';\nimport { DebugProtectionFunctionNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode';\nimport { DomainLockNode } from '../../../custom-nodes/domain-lock-nodes/DomainLockNode';\nimport { ExpressionWithOperatorControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode';\nimport { LogicalExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode';\nimport { NodeCallsControllerFunctionNode } from '../../../custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode';\nimport { SelfDefendingUnicodeNode } from '../../../custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode';\nimport { StringArrayCallsWrapper } from '../../../custom-nodes/string-array-nodes/StringArrayCallsWrapper';\nimport { StringArrayNode } from '../../../custom-nodes/string-array-nodes/StringArrayNode';\nimport { StringArrayRotateFunctionNode } from '../../../custom-nodes/string-array-nodes/StringArrayRotateFunctionNode';\n\nexport const customNodesModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // custom nodes\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BinaryExpressionFunctionNode)\n        .whenTargetNamed(CustomNodes.BinaryExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BlockStatementControlFlowFlatteningNode)\n        .whenTargetNamed(CustomNodes.BlockStatementControlFlowFlatteningNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(CallExpressionControlFlowStorageCallNode)\n        .whenTargetNamed(CustomNodes.CallExpressionControlFlowStorageCallNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(CallExpressionFunctionNode)\n        .whenTargetNamed(CustomNodes.CallExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(ControlFlowStorageNode)\n        .whenTargetNamed(CustomNodes.ControlFlowStorageNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(ConsoleOutputDisableExpressionNode)\n        .whenTargetNamed(CustomNodes.ConsoleOutputDisableExpressionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(DebugProtectionFunctionCallNode)\n        .whenTargetNamed(CustomNodes.DebugProtectionFunctionCallNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(DebugProtectionFunctionIntervalNode)\n        .whenTargetNamed(CustomNodes.DebugProtectionFunctionIntervalNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(DebugProtectionFunctionNode)\n        .whenTargetNamed(CustomNodes.DebugProtectionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(DomainLockNode)\n        .whenTargetNamed(CustomNodes.DomainLockNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(ExpressionWithOperatorControlFlowStorageCallNode)\n        .whenTargetNamed(CustomNodes.ExpressionWithOperatorControlFlowStorageCallNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(LogicalExpressionFunctionNode)\n        .whenTargetNamed(CustomNodes.LogicalExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(NodeCallsControllerFunctionNode)\n        .whenTargetNamed(CustomNodes.NodeCallsControllerFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(SelfDefendingUnicodeNode)\n        .whenTargetNamed(CustomNodes.SelfDefendingUnicodeNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(StringArrayCallsWrapper)\n        .whenTargetNamed(CustomNodes.StringArrayCallsWrapper);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(StringArrayNode)\n        .whenTargetNamed(CustomNodes.StringArrayNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(StringArrayRotateFunctionNode)\n        .whenTargetNamed(CustomNodes.StringArrayRotateFunctionNode);\n\n    // node groups\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(ConsoleOutputCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroups.ConsoleOutputCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(DebugProtectionCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroups.DebugProtectionCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(DomainLockCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroups.DomainLockCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(SelfDefendingCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroups.SelfDefendingCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(StringArrayCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroups.StringArrayCustomNodeGroup);\n\n    // customNode factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__ICustomNode)\n        .toFactory<ICustomNode>((context: interfaces.Context) => {\n            const cache: Map <CustomNodes, interfaces.Newable<ICustomNode>> = new Map();\n\n            let cachedOptions: IOptions;\n\n            return (customNodeName: CustomNodes) => {\n                if (!cachedOptions) {\n                    cachedOptions = context.container.get<IOptions>(ServiceIdentifiers.IOptions);\n                }\n\n                if (cache.has(customNodeName)) {\n                    return new (<interfaces.Newable<ICustomNode>>cache.get(customNodeName));\n                }\n\n                const constructor: interfaces.Newable<ICustomNode> = context.container\n                    .getNamed<interfaces.Newable<ICustomNode>>(\n                        ServiceIdentifiers.Newable__ICustomNode,\n                        customNodeName\n                    );\n\n                cache.set(customNodeName, constructor);\n\n                return new constructor(cachedOptions);\n            };\n        });\n\n    // customNodeGroup factory\n    bind<ICustomNodeGroup>(ServiceIdentifiers.Factory__ICustomNodeGroup)\n        .toFactory<ICustomNodeGroup>((context: interfaces.Context) => {\n            return (customNodeGroupName: CustomNodeGroups) => {\n                return context.container.getNamed<ICustomNodeGroup>(\n                    ServiceIdentifiers.ICustomNodeGroup,\n                    customNodeGroupName\n                );\n            };\n        });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/container/modules/custom-nodes/CustomNodesModule.ts","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IControlFlowReplacer } from '../../../interfaces/node-transformers/IControlFlowReplacer';\n\nimport { ControlFlowReplacers } from '../../../enums/container/ControlFlowReplacers';\n\nimport { BinaryExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer';\nimport { CallExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer';\nimport { LogicalExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer';\n\nexport const controlFlowTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(BinaryExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacers.BinaryExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(CallExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacers.CallExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(LogicalExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacers.LogicalExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.Factory__IControlFlowReplacer)\n        .toFactory<IControlFlowReplacer>((context: interfaces.Context) => {\n            const cache: Map <ControlFlowReplacers, IControlFlowReplacer> = new Map();\n\n            return (replacerName: ControlFlowReplacers) => {\n                if (cache.has(replacerName)) {\n                    return <IControlFlowReplacer>cache.get(replacerName);\n                }\n\n                const controlFlowReplacer: IControlFlowReplacer = context.container.getNamed<IControlFlowReplacer>(\n                    ServiceIdentifiers.IControlFlowReplacer,\n                    replacerName\n                );\n\n                cache.set(replacerName, controlFlowReplacer);\n\n                return controlFlowReplacer;\n            };\n        });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/container/modules/node-transformers/ControlFlowTransformersModule.ts","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\n\nimport { NodeTransformers } from '../../../enums/container/NodeTransformers';\n\nimport { FunctionControlFlowTransformer } from '../../../node-transformers/control-flow-transformers/FunctionControlFlowTransformer';\n\nimport { BlockStatementControlFlowTransformer } from '../../../node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer';\nimport { CatchClauseTransformer } from '../../../node-transformers/obfuscating-transformers/CatchClauseTransformer';\nimport { FunctionDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/FunctionDeclarationTransformer';\nimport { FunctionTransformer } from '../../../node-transformers/obfuscating-transformers/FunctionTransformer';\nimport { LabeledStatementTransformer } from '../../../node-transformers/obfuscating-transformers/LabeledStatementTransformer';\nimport { LiteralTransformer } from '../../../node-transformers/obfuscating-transformers/LiteralTransformer';\nimport { MemberExpressionTransformer } from '../../../node-transformers/converting-transformers/MemberExpressionTransformer';\nimport { MethodDefinitionTransformer } from '../../../node-transformers/converting-transformers/MethodDefinitionTransformer';\nimport { ObjectExpressionTransformer } from '../../../node-transformers/obfuscating-transformers/ObjectExpressionTransformer';\nimport { TemplateLiteralTransformer } from '../../../node-transformers/converting-transformers/TemplateLiteralTransformer';\nimport { VariableDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/VariableDeclarationTransformer';\n\nexport const nodeTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // control flow transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(BlockStatementControlFlowTransformer)\n        .whenTargetNamed(NodeTransformers.BlockStatementControlFlowTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionControlFlowTransformer)\n        .whenTargetNamed(NodeTransformers.FunctionControlFlowTransformer);\n\n    // converting transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MemberExpressionTransformer)\n        .whenTargetNamed(NodeTransformers.MemberExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MethodDefinitionTransformer)\n        .whenTargetNamed(NodeTransformers.MethodDefinitionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(TemplateLiteralTransformer)\n        .whenTargetNamed(NodeTransformers.TemplateLiteralTransformer);\n\n    // obfuscation transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CatchClauseTransformer)\n        .whenTargetNamed(NodeTransformers.CatchClauseTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionDeclarationTransformer)\n        .whenTargetNamed(NodeTransformers.FunctionDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionTransformer)\n        .whenTargetNamed(NodeTransformers.FunctionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(LabeledStatementTransformer)\n        .whenTargetNamed(NodeTransformers.LabeledStatementTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(LiteralTransformer)\n        .whenTargetNamed(NodeTransformers.LiteralTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObjectExpressionTransformer)\n        .whenTargetNamed(NodeTransformers.ObjectExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(VariableDeclarationTransformer)\n        .whenTargetNamed(NodeTransformers.VariableDeclarationTransformer);\n\n    // node transformers factory\n    bind<INodeTransformer>(ServiceIdentifiers.Factory__INodeTransformer)\n        .toFactory<INodeTransformer>((context: interfaces.Context) => {\n            const cache: Map <NodeTransformers, INodeTransformer> = new Map();\n\n            return (nodeTransformerName: NodeTransformers) => {\n                if (cache.has(nodeTransformerName)) {\n                    return <INodeTransformer>cache.get(nodeTransformerName);\n                }\n\n                const nodeTransformer: INodeTransformer = context.container\n                    .getNamed<INodeTransformer>(\n                        ServiceIdentifiers.INodeTransformer,\n                        nodeTransformerName\n                    );\n\n                cache.set(nodeTransformerName, nodeTransformer);\n\n                return nodeTransformer;\n            };\n        });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/container/modules/node-transformers/NodeTransformersModule.ts","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IObfuscationReplacer } from '../../../interfaces/node-transformers/IObfuscationReplacer';\n\nimport { ObfuscationReplacers } from '../../../enums/container/ObfuscationReplacers';\n\nimport { BooleanLiteralReplacer } from '../../../node-transformers/obfuscating-transformers/replacers/BooleanLiteralReplacer';\nimport { IdentifierReplacer } from '../../../node-transformers/obfuscating-transformers/replacers/IdentifierReplacer';\nimport { NumberLiteralReplacer } from '../../../node-transformers/obfuscating-transformers/replacers/NumberLiteralReplacer';\nimport { StringLiteralReplacer } from '../../../node-transformers/obfuscating-transformers/replacers/StringLiteralReplacer';\n\nexport const obfuscatingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    bind<IObfuscationReplacer>(ServiceIdentifiers.IObfuscationReplacer)\n        .to(BooleanLiteralReplacer)\n        .whenTargetNamed(ObfuscationReplacers.BooleanReplacer);\n\n    bind<IObfuscationReplacer>(ServiceIdentifiers.IObfuscationReplacer)\n        .to(IdentifierReplacer)\n        .whenTargetNamed(ObfuscationReplacers.IdentifierReplacer);\n\n    bind<IObfuscationReplacer>(ServiceIdentifiers.IObfuscationReplacer)\n        .to(NumberLiteralReplacer)\n        .whenTargetNamed(ObfuscationReplacers.NumberLiteralReplacer);\n\n    bind<IObfuscationReplacer>(ServiceIdentifiers.IObfuscationReplacer)\n        .to(StringLiteralReplacer)\n        .whenTargetNamed(ObfuscationReplacers.StringLiteralReplacer);\n\n    bind<IObfuscationReplacer>(ServiceIdentifiers.Factory__IObfuscationReplacer)\n        .toFactory<IObfuscationReplacer>((context: interfaces.Context) => {\n            const cache: Map <ObfuscationReplacers, IObfuscationReplacer> = new Map();\n\n            return (replacerName: ObfuscationReplacers) => {\n                if (cache.has(replacerName)) {\n                    return <IObfuscationReplacer>cache.get(replacerName);\n                }\n\n                const obfuscationReplacer: IObfuscationReplacer = context.container.getNamed<IObfuscationReplacer>(\n                    ServiceIdentifiers.IObfuscationReplacer,\n                    replacerName\n                );\n\n                cache.set(replacerName, obfuscationReplacer);\n\n                return obfuscationReplacer;\n            };\n        });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/container/modules/node-transformers/ObfuscatingTransformersModule.ts","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { ICalleeDataExtractor } from '../../../interfaces/stack-trace-analyzer/ICalleeDataExtractor';\nimport { IStackTraceAnalyzer } from '../../../interfaces/stack-trace-analyzer/IStackTraceAnalyzer';\n\nimport { CalleeDataExtractors } from '../../../enums/container/CalleeDataExtractors';\nimport { FunctionDeclarationCalleeDataExtractor } from '../../../stack-trace-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor';\nimport { FunctionExpressionCalleeDataExtractor } from '../../../stack-trace-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor';\nimport { ObjectExpressionCalleeDataExtractor } from '../../../stack-trace-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor';\nimport { StackTraceAnalyzer } from '../../../stack-trace-analyzer/StackTraceAnalyzer';\n\nexport const stackTraceAnalyzerModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // stack trace analyzer\n    bind<IStackTraceAnalyzer>(ServiceIdentifiers.IStackTraceAnalyzer)\n        .to(StackTraceAnalyzer)\n        .inSingletonScope();\n\n    // callee data extractors\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(FunctionDeclarationCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractors.FunctionDeclarationCalleeDataExtractor);\n\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(FunctionExpressionCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractors.FunctionExpressionCalleeDataExtractor);\n\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(ObjectExpressionCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractors.ObjectExpressionCalleeDataExtractor);\n\n    // node transformers factory\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.Factory__ICalleeDataExtractor)\n        .toFactory<ICalleeDataExtractor>((context: interfaces.Context) => {\n            const cache: Map <CalleeDataExtractors, ICalleeDataExtractor> = new Map();\n\n            return (calleeDataExtractorName: CalleeDataExtractors) => {\n                if (cache.has(calleeDataExtractorName)) {\n                    return <ICalleeDataExtractor>cache.get(calleeDataExtractorName);\n                }\n\n                const calleeDataExtractor: ICalleeDataExtractor = context.container.getNamed<ICalleeDataExtractor>(\n                    ServiceIdentifiers.ICalleeDataExtractor,\n                    calleeDataExtractorName\n                );\n\n                cache.set(calleeDataExtractorName, calleeDataExtractor);\n\n                return calleeDataExtractor;\n            };\n        });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/container/modules/stack-trace-analyzer/StackTraceAnalyzerModule.ts","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TCustomNodeGroupStorage } from '../../../types/storages/TCustomNodeGroupStorage';\nimport { TStringArrayStorage } from '../../../types/storages/TStringArrayStorage';\n\nimport { ControlFlowStorage } from '../../../storages/control-flow/ControlFlowStorage';\nimport { CustomNodeGroupStorage } from '../../../storages/custom-node-group/CustomNodeGroupStorage';\nimport { StringArrayStorage } from '../../../storages/string-array/StringArrayStorage';\n\nexport const storagesModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // storages\n    bind<TCustomNodeGroupStorage>(ServiceIdentifiers.TCustomNodeGroupStorage)\n        .to(CustomNodeGroupStorage)\n        .inSingletonScope();\n\n    bind<TStringArrayStorage>(ServiceIdentifiers.TStringArrayStorage)\n        .to(StringArrayStorage)\n        .inSingletonScope();\n\n    bind<interfaces.Newable<TControlFlowStorage>>(ServiceIdentifiers.Newable__TControlFlowStorage)\n        .toConstructor(ControlFlowStorage);\n\n    // controlFlowStorage factory\n    bind<TControlFlowStorage>(ServiceIdentifiers.Factory__TControlFlowStorage)\n        .toFactory<TControlFlowStorage>((context: interfaces.Context) => {\n            return () => {\n                const constructor: interfaces.Newable<TControlFlowStorage> = context.container\n                    .get<interfaces.Newable<TControlFlowStorage>>(ServiceIdentifiers.Newable__TControlFlowStorage);\n\n                return new constructor();\n            };\n        });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/container/modules/storages/StoragesModule.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as format from 'string-template';\n\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { ConsoleOutputDisableExpressionTemplate } from '../../templates/custom-nodes/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { RandomGeneratorUtils } from '../../utils/RandomGeneratorUtils';\n\n@injectable()\nexport class ConsoleOutputDisableExpressionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName: string;\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(ConsoleOutputDisableExpressionTemplate(), {\n            consoleLogDisableFunctionName: RandomGeneratorUtils.getRandomVariableName(6),\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/TCustomNodeFactory';\nimport { TNodeWithBlockStatement } from '../../../types/node/TNodeWithBlockStatement';\nimport { TObfuscationEvent } from '../../../types/event-emitters/TObfuscationEvent';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IObfuscationEventEmitter } from '../../../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IStackTraceData } from '../../../interfaces/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNodes } from '../../../enums/container/CustomNodes';\nimport { ObfuscationEvents } from '../../../enums/ObfuscationEvents';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { RandomGeneratorUtils } from '../../../utils/RandomGeneratorUtils';\n\n@injectable()\nexport class ConsoleOutputCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {TObfuscationEvent}\n     */\n    protected readonly appendEvent: TObfuscationEvent = ObfuscationEvents.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNodes, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes: Map <CustomNodes, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @type {IObfuscationEventEmitter}\n     */\n    private readonly obfuscationEventEmitter: IObfuscationEventEmitter;\n\n    /**\n     * @param customNodeFactory\n     * @param obfuscationEventEmitter\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.IObfuscationEventEmitter) obfuscationEventEmitter: IObfuscationEventEmitter,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.customNodeFactory = customNodeFactory;\n        this.obfuscationEventEmitter = obfuscationEventEmitter;\n    }\n\n    /**\n     * @param blockScopeNode\n     * @param stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockStatement, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = NodeAppender.getRandomStackTraceIndex(stackTraceData.length);\n\n        // consoleOutputDisableExpressionNode append\n        this.appendCustomNodeIfExist(CustomNodes.ConsoleOutputDisableExpressionNode, (customNode: ICustomNode) => {\n            NodeAppender.appendNodeToOptimalBlockScope(\n                stackTraceData,\n                blockScopeNode,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNodes.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            let targetBlockScope: TNodeWithBlockStatement;\n\n            if (stackTraceData.length) {\n                targetBlockScope = NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1);\n            } else {\n                targetBlockScope = blockScopeNode;\n            }\n\n            NodeAppender.prependNode(targetBlockScope, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNodes, ICustomNode> ();\n\n        if (!this.options.disableConsoleOutput) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = RandomGeneratorUtils.getRandomVariableName(6);\n\n        const consoleOutputDisableExpressionNode: ICustomNode = this.customNodeFactory(CustomNodes.ConsoleOutputDisableExpressionNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNodes.NodeCallsControllerFunctionNode);\n\n        consoleOutputDisableExpressionNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNodes.ConsoleOutputDisableExpressionNode, consoleOutputDisableExpressionNode);\n        this.customNodes.set(CustomNodes.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { BinaryOperator } from 'estree';\n\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { Nodes } from '../../node/Nodes';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { RandomGeneratorUtils } from '../../utils/RandomGeneratorUtils';\n\n@injectable()\nexport class BinaryExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {BinaryOperator}\n     */\n    @initializable()\n    private operator: BinaryOperator;\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param operator\n     */\n    public initialize (operator: BinaryOperator): void {\n        this.operator = operator;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = Nodes.getFunctionDeclarationNode(\n            RandomGeneratorUtils.getRandomString(3),\n            [\n                Nodes.getIdentifierNode('x'),\n                Nodes.getIdentifierNode('y')\n            ],\n            Nodes.getBlockStatementNode([\n                Nodes.getReturnStatementNode(\n                    Nodes.getBinaryExpressionNode(\n                        this.operator,\n                        Nodes.getIdentifierNode('x'),\n                        Nodes.getIdentifierNode('y')\n                    )\n                )\n            ])\n        );\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { Nodes } from '../../node/Nodes';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { RandomGeneratorUtils } from '../../utils/RandomGeneratorUtils';\n\n@injectable()\nexport class BlockStatementControlFlowFlatteningNode extends AbstractCustomNode {\n    /**\n     * @type {ESTree.Statement[]}\n     */\n    @initializable()\n    private blockStatementBody: ESTree.Statement[];\n\n    /**\n     * @type {number[]}\n     */\n    @initializable()\n    private originalKeysIndexesInShuffledArray: number[];\n\n    /**\n     * @type {number[]}\n     */\n    @initializable()\n    private shuffledKeys: number[];\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /***\n     * @param blockStatementBody\n     * @param shuffledKeys\n     * @param originalKeysIndexesInShuffledArray\n     */\n    public initialize (\n        blockStatementBody: ESTree.Statement[],\n        shuffledKeys: number[],\n        originalKeysIndexesInShuffledArray: number[]\n    ): void {\n        this.blockStatementBody = blockStatementBody;\n        this.shuffledKeys = shuffledKeys;\n        this.originalKeysIndexesInShuffledArray = originalKeysIndexesInShuffledArray;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const controllerIdentifierName: string = RandomGeneratorUtils.getRandomString(3);\n        const indexIdentifierName: string = RandomGeneratorUtils.getRandomString(3);\n        const structure: ESTree.BlockStatement = Nodes.getBlockStatementNode([\n            Nodes.getVariableDeclarationNode([\n                Nodes.getVariableDeclaratorNode(\n                    Nodes.getIdentifierNode(controllerIdentifierName),\n                    Nodes.getCallExpressionNode(\n                        Nodes.getMemberExpressionNode(\n                            Nodes.getLiteralNode(\n                                this.originalKeysIndexesInShuffledArray.join('|')\n                            ),\n                            Nodes.getIdentifierNode('split')\n                        ),\n                        [\n                            Nodes.getLiteralNode('|')\n                        ]\n                    )\n                ),\n                Nodes.getVariableDeclaratorNode(\n                    Nodes.getIdentifierNode(indexIdentifierName),\n                    Nodes.getLiteralNode(0)\n                )\n            ]),\n            Nodes.getWhileStatementNode(\n                Nodes.getLiteralNode(true),\n                Nodes.getBlockStatementNode([\n                    Nodes.getSwitchStatementNode(\n                        Nodes.getMemberExpressionNode(\n                            Nodes.getIdentifierNode(controllerIdentifierName),\n                            Nodes.getUpdateExpressionNode(\n                                '++',\n                                Nodes.getIdentifierNode(indexIdentifierName)\n                            ),\n                            true\n                        ),\n                        this.shuffledKeys.map((key: number, index: number) => {\n                            return Nodes.getSwitchCaseNode(\n                                Nodes.getLiteralNode(String(index)),\n                                [\n                                    this.blockStatementBody[key],\n                                    Nodes.getContinueStatement()\n                                ]\n                            );\n                        })\n                    ),\n                    Nodes.getBreakStatement()\n                ])\n            )\n        ]);\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { Nodes } from '../../node/Nodes';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { RandomGeneratorUtils } from '../../utils/RandomGeneratorUtils';\n\n@injectable()\nexport class CallExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {(ESTree.Expression | ESTree.SpreadElement)[]}\n     */\n    @initializable()\n    private expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[];\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param expressionArguments\n     */\n    public initialize (expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]): void {\n        this.expressionArguments = expressionArguments;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const calleeIdentifier: ESTree.Identifier = Nodes.getIdentifierNode('callee');\n        const params: ESTree.Identifier[] = [];\n        const argumentsLength: number = this.expressionArguments.length;\n\n        for (let i: number = 0; i < argumentsLength; i++) {\n            params.push(Nodes.getIdentifierNode(`param${i + 1}`));\n        }\n\n        const structure: TStatement = Nodes.getFunctionDeclarationNode(\n            RandomGeneratorUtils.getRandomString(3),\n            [\n                calleeIdentifier,\n                ...params\n            ],\n            Nodes.getBlockStatementNode([\n                Nodes.getReturnStatementNode(\n                    Nodes.getCallExpressionNode(\n                        calleeIdentifier,\n                        params\n                    )\n                )\n            ])\n        );\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { LogicalOperator } from 'estree';\n\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { Nodes } from '../../node/Nodes';\nimport { RandomGeneratorUtils } from '../../utils/RandomGeneratorUtils';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class LogicalExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {LogicalOperator}\n     */\n    @initializable()\n    private operator: LogicalOperator;\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param operator\n     */\n    public initialize (operator: LogicalOperator): void {\n        this.operator = operator;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = Nodes.getFunctionDeclarationNode(\n            RandomGeneratorUtils.getRandomString(3),\n            [\n                Nodes.getIdentifierNode('x'),\n                Nodes.getIdentifierNode('y')\n            ],\n            Nodes.getBlockStatementNode([\n                Nodes.getReturnStatementNode(\n                    Nodes.getLogicalExpressionNode(\n                        this.operator,\n                        Nodes.getIdentifierNode('x'),\n                        Nodes.getIdentifierNode('y')\n                    )\n                )\n            ])\n        );\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\nimport { Expression } from 'estree';\n\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { Nodes } from '../../../node/Nodes';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class CallExpressionControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {Expression}\n     */\n    @initializable()\n    private callee: Expression;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName: string;\n\n    /**\n     * @type {(ESTree.Expression | ESTree.SpreadElement)[]}\n     */\n    @initializable()\n    private expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[];\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param controlFlowStorageName\n     * @param controlFlowStorageKey\n     * @param callee\n     * @param expressionArguments\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string,\n        callee: Expression,\n        expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n        this.callee = callee;\n        this.expressionArguments = expressionArguments;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = Nodes.getExpressionStatementNode(\n            Nodes.getCallExpressionNode(\n                Nodes.getMemberExpressionNode(\n                    Nodes.getIdentifierNode(this.controlFlowStorageName),\n                    Nodes.getIdentifierNode(this.controlFlowStorageKey)\n                ),\n                [\n                    this.callee,\n                    ...this.expressionArguments\n                ]\n            )\n        );\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IStorage } from '../../../interfaces/storages/IStorage';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { Nodes } from '../../../node/Nodes';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ControlFlowStorageNode extends AbstractCustomNode {\n    /**\n     * @type {IStorage <ICustomNode>}\n     */\n    @initializable()\n    private controlFlowStorage: IStorage <ICustomNode>;\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param controlFlowStorage\n     */\n    public initialize (controlFlowStorage: IStorage <ICustomNode>): void {\n        this.controlFlowStorage = controlFlowStorage;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        let structure: ESTree.Node = Nodes.getVariableDeclarationNode([\n            Nodes.getVariableDeclaratorNode(\n                Nodes.getIdentifierNode(this.controlFlowStorage.getStorageId()),\n                Nodes.getObjectExpressionNode(\n                    Array\n                        .from(this.controlFlowStorage.getStorage())\n                        .map(([key, value]: [string, ICustomNode]) => {\n                            return Nodes.getPropertyNode(\n                                Nodes.getIdentifierNode(key),\n                                <any>value.getNode()[0]\n                            );\n                        })\n                )\n            )\n        ]);\n\n        structure = NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { Expression } from 'estree';\n\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { Nodes } from '../../../node/Nodes';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ExpressionWithOperatorControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName: string;\n\n    /**\n     * @type {Expression}\n     */\n    @initializable()\n    private leftValue: Expression;\n\n    /**\n     * @type {ESTree.Expression}\n     */\n    @initializable()\n    private rightValue: Expression;\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param controlFlowStorageName\n     * @param controlFlowStorageKey\n     * @param leftValue\n     * @param rightValue\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string,\n        leftValue: Expression,\n        rightValue: Expression,\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n        this.leftValue = leftValue;\n        this.rightValue = rightValue;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = Nodes.getExpressionStatementNode(\n            Nodes.getCallExpressionNode(\n                Nodes.getMemberExpressionNode(\n                    Nodes.getIdentifierNode(this.controlFlowStorageName),\n                    Nodes.getIdentifierNode(this.controlFlowStorageKey)\n                ),\n                [\n                    this.leftValue,\n                    this.rightValue\n                ]\n            )\n        );\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as format from 'string-template';\n\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebugProtectionFunctionCallTemplate } from '../../templates/custom-nodes/debug-protection-nodes/debug-protection-function-call-node/DebufProtectionFunctionCallTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName: string;\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param debugProtectionFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(DebugProtectionFunctionCallTemplate(), {\n            debugProtectionFunctionName: this.debugProtectionFunctionName\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as format from 'string-template';\n\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebugProtectionFunctionIntervalTemplate } from '../../templates/custom-nodes/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionIntervalNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName: string;\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param debugProtectionFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(DebugProtectionFunctionIntervalTemplate(), {\n            debugProtectionFunctionName: this.debugProtectionFunctionName\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as format from 'string-template';\n\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebugProtectionFunctionTemplate } from '../../templates/custom-nodes/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName: string;\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param debugProtectionFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(DebugProtectionFunctionTemplate(), {\n            debugProtectionFunctionName: this.debugProtectionFunctionName\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/TCustomNodeFactory';\nimport { TNodeWithBlockStatement } from '../../../types/node/TNodeWithBlockStatement';\nimport { TObfuscationEvent } from '../../../types/event-emitters/TObfuscationEvent';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IObfuscationEventEmitter } from '../../../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IStackTraceData } from '../../../interfaces/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNodes } from '../../../enums/container/CustomNodes';\nimport { ObfuscationEvents } from '../../../enums/ObfuscationEvents';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { RandomGeneratorUtils } from '../../../utils/RandomGeneratorUtils';\n\n@injectable()\nexport class DebugProtectionCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {TObfuscationEvent}\n     */\n    protected readonly appendEvent: TObfuscationEvent = ObfuscationEvents.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNodes, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes: Map <CustomNodes, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @type {IObfuscationEventEmitter}\n     */\n    private readonly obfuscationEventEmitter: IObfuscationEventEmitter;\n\n    /**\n     * @param customNodeFactory\n     * @param obfuscationEventEmitter\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.IObfuscationEventEmitter) obfuscationEventEmitter: IObfuscationEventEmitter,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.customNodeFactory = customNodeFactory;\n        this.obfuscationEventEmitter = obfuscationEventEmitter;\n    }\n\n    /**\n     * @param blockScopeNode\n     * @param stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockStatement, stackTraceData: IStackTraceData[]): void {\n        // debugProtectionFunctionNode append\n        this.appendCustomNodeIfExist(CustomNodes.DebugProtectionFunctionNode, (customNode: ICustomNode) => {\n            NodeAppender.appendNode(blockScopeNode, customNode.getNode());\n        });\n\n        // debugProtectionFunctionCallNode append\n        this.appendCustomNodeIfExist(CustomNodes.DebugProtectionFunctionCallNode, (customNode: ICustomNode) => {\n            NodeAppender.appendNode(blockScopeNode, customNode.getNode());\n        });\n\n        // debugProtectionFunctionIntervalNode append\n        this.appendCustomNodeIfExist(CustomNodes.DebugProtectionFunctionIntervalNode, (customNode: ICustomNode) => {\n            const programBodyLength: number = blockScopeNode.body.length;\n            const randomIndex: number = RandomGeneratorUtils.getRandomInteger(0, programBodyLength);\n\n            NodeAppender.insertNodeAtIndex(blockScopeNode, customNode.getNode(), randomIndex);\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNodes, ICustomNode> ();\n\n        if (!this.options.debugProtection) {\n            return;\n        }\n\n        const debugProtectionFunctionName: string = RandomGeneratorUtils.getRandomVariableName(6);\n\n        const debugProtectionFunctionNode: ICustomNode = this.customNodeFactory(CustomNodes.DebugProtectionFunctionNode);\n        const debugProtectionFunctionCallNode: ICustomNode = this.customNodeFactory(CustomNodes.DebugProtectionFunctionCallNode);\n        const debugProtectionFunctionIntervalNode: ICustomNode = this.customNodeFactory(CustomNodes.DebugProtectionFunctionIntervalNode);\n\n        debugProtectionFunctionNode.initialize(debugProtectionFunctionName);\n        debugProtectionFunctionCallNode.initialize(debugProtectionFunctionName);\n        debugProtectionFunctionIntervalNode.initialize(debugProtectionFunctionName);\n\n        this.customNodes.set(CustomNodes.DebugProtectionFunctionNode, debugProtectionFunctionNode);\n        this.customNodes.set(CustomNodes.DebugProtectionFunctionCallNode, debugProtectionFunctionCallNode);\n\n        if (this.options.debugProtectionInterval) {\n            this.customNodes.set(CustomNodes.DebugProtectionFunctionIntervalNode, debugProtectionFunctionIntervalNode);\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as format from 'string-template';\n\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DomainLockNodeTemplate } from '../../templates/custom-nodes/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { CryptUtils } from '../../utils/CryptUtils';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { RandomGeneratorUtils } from '../../utils/RandomGeneratorUtils';\n\n@injectable()\nexport class DomainLockNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected callsControllerFunctionName: string;\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const domainsString: string = this.options.domainLock.join(';');\n        const [hiddenDomainsString, diff]: string[] = CryptUtils.hideString(domainsString, domainsString.length * 3);\n\n        return format(DomainLockNodeTemplate(), {\n            domainLockFunctionName: RandomGeneratorUtils.getRandomVariableName(6),\n            diff: diff,\n            domains: hiddenDomainsString,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/domain-lock-nodes/DomainLockNode.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/TCustomNodeFactory';\nimport { TNodeWithBlockStatement } from '../../../types/node/TNodeWithBlockStatement';\nimport { TObfuscationEvent } from '../../../types/event-emitters/TObfuscationEvent';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IObfuscationEventEmitter } from '../../../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IStackTraceData } from '../../../interfaces/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNodes } from '../../../enums/container/CustomNodes';\nimport { ObfuscationEvents } from '../../../enums/ObfuscationEvents';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { RandomGeneratorUtils } from '../../../utils/RandomGeneratorUtils';\n\n@injectable()\nexport class DomainLockCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {TObfuscationEvent}\n     */\n    protected readonly appendEvent: TObfuscationEvent = ObfuscationEvents.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNodes, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes: Map <CustomNodes, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @type {IObfuscationEventEmitter}\n     */\n    private readonly obfuscationEventEmitter: IObfuscationEventEmitter;\n\n    /**\n     * @param customNodeFactory\n     * @param obfuscationEventEmitter\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.IObfuscationEventEmitter) obfuscationEventEmitter: IObfuscationEventEmitter,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.customNodeFactory = customNodeFactory;\n        this.obfuscationEventEmitter = obfuscationEventEmitter;\n    }\n\n    /**\n     * @param blockScopeNode\n     * @param stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockStatement, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = NodeAppender.getRandomStackTraceIndex(stackTraceData.length);\n\n        // domainLockNode append\n        this.appendCustomNodeIfExist(CustomNodes.DomainLockNode, (customNode: ICustomNode) => {\n            NodeAppender.appendNodeToOptimalBlockScope(\n                stackTraceData,\n                blockScopeNode,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNodes.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            let targetBlockScope: TNodeWithBlockStatement;\n\n            if (stackTraceData.length) {\n                targetBlockScope = NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1);\n            } else {\n                targetBlockScope = blockScopeNode;\n            }\n\n            NodeAppender.prependNode(targetBlockScope, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNodes, ICustomNode> ();\n\n        if (!this.options.domainLock.length) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = RandomGeneratorUtils.getRandomVariableName(6);\n\n        const domainLockNode: ICustomNode = this.customNodeFactory(CustomNodes.DomainLockNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNodes.NodeCallsControllerFunctionNode);\n\n        domainLockNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNodes.DomainLockNode, domainLockNode);\n        this.customNodes.set(CustomNodes.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as format from 'string-template';\n\nimport { TObfuscationEvent } from '../../types/event-emitters/TObfuscationEvent';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { ObfuscationEvents } from '../../enums/ObfuscationEvents';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { SingleNodeCallControllerTemplate } from '../../templates/custom-nodes/SingleNodeCallControllerTemplate';\n\nimport { NO_CUSTOM_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscator';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class NodeCallsControllerFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected callsControllerFunctionName: string;\n\n    /**\n     * @type {TObfuscationEvent}\n     */\n    @initializable()\n    private appendEvent: TObfuscationEvent;\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param appendEvent\n     * @param callsControllerFunctionName\n     */\n    public initialize (appendEvent: TObfuscationEvent, callsControllerFunctionName: string): void {\n        this.appendEvent = appendEvent;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        if (this.appendEvent === ObfuscationEvents.AfterObfuscation) {\n            return JavaScriptObfuscator.obfuscate(\n                format(SingleNodeCallControllerTemplate(), {\n                    singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n                }),\n                {\n                    ...NO_CUSTOM_NODES_PRESET,\n                    seed: this.options.seed\n                }\n            ).getObfuscatedCode();\n        }\n\n        return format(SingleNodeCallControllerTemplate(), {\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as format from 'string-template';\n\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_CUSTOM_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { SelfDefendingTemplate } from '../../templates/custom-nodes/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscator';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { RandomGeneratorUtils } from '../../utils/RandomGeneratorUtils';\n\n@injectable()\nexport class SelfDefendingUnicodeNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected callsControllerFunctionName: string;\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return JavaScriptObfuscator.obfuscate(\n            format(SelfDefendingTemplate(), {\n                selfDefendingFunctionName: RandomGeneratorUtils.getRandomVariableName(6),\n                singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n            }),\n            {\n                ...NO_CUSTOM_NODES_PRESET,\n                seed: this.options.seed\n            }\n        ).getObfuscatedCode();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/TCustomNodeFactory';\nimport { TObfuscationEvent } from '../../../types/event-emitters/TObfuscationEvent';\nimport { TNodeWithBlockStatement } from '../../../types/node/TNodeWithBlockStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IObfuscationEventEmitter } from '../../../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IStackTraceData } from '../../../interfaces/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNodes } from '../../../enums/container/CustomNodes';\nimport { ObfuscationEvents } from '../../../enums/ObfuscationEvents';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { RandomGeneratorUtils } from '../../../utils/RandomGeneratorUtils';\n\n@injectable()\nexport class SelfDefendingCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {TObfuscationEvent}\n     */\n    protected appendEvent: TObfuscationEvent = ObfuscationEvents.AfterObfuscation;\n\n    /**\n     * @type {Map<CustomNodes, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes: Map <CustomNodes, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @type {IObfuscationEventEmitter}\n     */\n    private readonly obfuscationEventEmitter: IObfuscationEventEmitter;\n\n    /**\n     * @param customNodeFactory\n     * @param obfuscationEventEmitter\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.IObfuscationEventEmitter) obfuscationEventEmitter: IObfuscationEventEmitter,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.customNodeFactory = customNodeFactory;\n        this.obfuscationEventEmitter = obfuscationEventEmitter;\n    }\n\n    /**\n     * @param blockScopeNode\n     * @param stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockStatement, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = NodeAppender.getRandomStackTraceIndex(stackTraceData.length);\n\n        // selfDefendingUnicodeNode append\n        this.appendCustomNodeIfExist(CustomNodes.SelfDefendingUnicodeNode, (customNode: ICustomNode) => {\n            NodeAppender.appendNodeToOptimalBlockScope(\n                stackTraceData,\n                blockScopeNode,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNodes.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            let targetBlockScope: TNodeWithBlockStatement;\n\n            if (stackTraceData.length) {\n                targetBlockScope = NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1);\n            } else {\n                targetBlockScope = blockScopeNode;\n            }\n\n            NodeAppender.prependNode(targetBlockScope, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNodes, ICustomNode> ();\n\n        if (!this.options.selfDefending) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = RandomGeneratorUtils.getRandomVariableName(6);\n\n        const selfDefendingUnicodeNode: ICustomNode = this.customNodeFactory(CustomNodes.SelfDefendingUnicodeNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNodes.NodeCallsControllerFunctionNode);\n\n        selfDefendingUnicodeNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNodes.SelfDefendingUnicodeNode, selfDefendingUnicodeNode);\n        this.customNodes.set(CustomNodes.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as format from 'string-template';\n\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IStorage } from '../../interfaces/storages/IStorage';\n\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_CUSTOM_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { AtobTemplate } from '../../templates/custom-nodes/AtobTemplate';\nimport { Rc4Template } from '../../templates/custom-nodes/Rc4Template';\nimport { SelfDefendingTemplate } from '../../templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate';\nimport { StringArrayBase64DecodeNodeTemplate } from '../../templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate';\nimport { StringArrayCallsWrapperTemplate } from '../../templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate';\nimport { StringArrayRc4DecodeNodeTemplate } from '../../templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscator';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class StringArrayCallsWrapper extends AbstractCustomNode {\n    /**\n     * @type {IStorage <string>}\n     */\n    @initializable()\n    private stringArrayStorage: IStorage <string>;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayCallsWrapperName: string;\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param stringArrayStorage\n     * @param stringArrayName\n     * @param stringArrayCallsWrapperName\n     */\n    public initialize (\n        stringArrayStorage: IStorage <string>,\n        stringArrayName: string,\n        stringArrayCallsWrapperName: string\n    ): void {\n        this.stringArrayStorage = stringArrayStorage;\n        this.stringArrayName = stringArrayName;\n        this.stringArrayCallsWrapperName = stringArrayCallsWrapperName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const decodeNodeTemplate: string = this.getDecodeStringArrayTemplate();\n\n        return JavaScriptObfuscator.obfuscate(\n            format(StringArrayCallsWrapperTemplate(), {\n                decodeNodeTemplate,\n                stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                stringArrayName: this.stringArrayName\n            }),\n            {\n                ...NO_CUSTOM_NODES_PRESET,\n                seed: this.options.seed\n            }\n        ).getObfuscatedCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    private getDecodeStringArrayTemplate (): string {\n        let decodeStringArrayTemplate: string = '',\n            selfDefendingCode: string = '';\n\n        if (this.options.selfDefending) {\n            selfDefendingCode = format(SelfDefendingTemplate(), {\n                stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                stringArrayName: this.stringArrayName\n            });\n        }\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.rc4:\n                decodeStringArrayTemplate = format(StringArrayRc4DecodeNodeTemplate(), {\n                    atobPolyfill: AtobTemplate(),\n                    rc4Polyfill: Rc4Template(),\n                    selfDefendingCode,\n                    stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                });\n\n                break;\n\n            case StringArrayEncoding.base64:\n                decodeStringArrayTemplate = format(StringArrayBase64DecodeNodeTemplate(), {\n                    atobPolyfill: AtobTemplate(),\n                    selfDefendingCode,\n                    stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                });\n\n                break;\n        }\n\n        return decodeStringArrayTemplate;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/string-array-nodes/StringArrayCallsWrapper.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as format from 'string-template';\n\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IStorage } from '../../interfaces/storages/IStorage';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { StringArrayTemplate } from '../../templates/custom-nodes/string-array-nodes/string-array-node/StringArrayTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { StringArrayStorage } from '../../storages/string-array/StringArrayStorage';\n\n@injectable()\nexport class StringArrayNode extends AbstractCustomNode {\n    /**\n     * @type {IStorage <string>}\n     */\n    @initializable()\n    private stringArrayStorage: IStorage <string>;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName: string;\n\n    /**\n     * @type {number}\n     */\n    @initializable()\n    private stringArrayRotateValue: number;\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param stringArrayStorage\n     * @param stringArrayName\n     * @param stringArrayRotateValue\n     */\n    public initialize (\n        stringArrayStorage: IStorage <string>,\n        stringArrayName: string,\n        stringArrayRotateValue: number\n    ): void {\n        this.stringArrayStorage = stringArrayStorage;\n        this.stringArrayName = stringArrayName;\n        this.stringArrayRotateValue = stringArrayRotateValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        (<StringArrayStorage>this.stringArrayStorage).rotateArray(this.stringArrayRotateValue);\n\n        return super.getNode();\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(StringArrayTemplate(), {\n            stringArrayName: this.stringArrayName,\n            stringArray: this.stringArrayStorage.toString()\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/string-array-nodes/StringArrayNode.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as format from 'string-template';\n\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IStorage } from '../../interfaces/storages/IStorage';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_CUSTOM_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { SelfDefendingTemplate } from '../../templates/custom-nodes/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate';\nimport { StringArrayRotateFunctionTemplate } from '../../templates/custom-nodes/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscator';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { RandomGeneratorUtils } from '../../utils/RandomGeneratorUtils';\nimport { Utils } from '../../utils/Utils';\n\n@injectable()\nexport class StringArrayRotateFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {IStorage <string>}\n     */\n    @initializable()\n    private stringArrayStorage: IStorage <string>;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName: string;\n\n    /**\n     * @param {number}\n     */\n    @initializable()\n    private stringArrayRotateValue: number;\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param stringArrayStorage\n     * @param stringArrayName\n     * @param stringArrayRotateValue\n     */\n    public initialize (\n        stringArrayStorage: IStorage <string>,\n        stringArrayName: string,\n        stringArrayRotateValue: number\n    ): void {\n        this.stringArrayStorage = stringArrayStorage;\n        this.stringArrayName = stringArrayName;\n        this.stringArrayRotateValue = stringArrayRotateValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const timesName: string = RandomGeneratorUtils.getRandomVariableName(6);\n        const whileFunctionName: string = RandomGeneratorUtils.getRandomVariableName(6);\n\n        let code: string = '';\n\n        if (this.options.selfDefending) {\n            code = format(SelfDefendingTemplate(), {\n                timesName,\n                whileFunctionName\n            });\n        } else {\n            code = `${whileFunctionName}(++${timesName})`;\n        }\n\n        return JavaScriptObfuscator.obfuscate(\n            format(StringArrayRotateFunctionTemplate(), {\n                code,\n                timesName,\n                stringArrayName: this.stringArrayName,\n                stringArrayRotateValue: Utils.decToHex(this.stringArrayRotateValue),\n                whileFunctionName\n            }),\n            {\n                ...NO_CUSTOM_NODES_PRESET,\n                seed: this.options.seed\n            }\n        ).getObfuscatedCode();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/string-array-nodes/StringArrayRotateFunctionNode.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/TCustomNodeFactory';\nimport { TNodeWithBlockStatement } from '../../../types/node/TNodeWithBlockStatement';\nimport { TObfuscationEvent } from '../../../types/event-emitters/TObfuscationEvent';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IObfuscationEventEmitter } from '../../../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IStackTraceData } from '../../../interfaces/stack-trace-analyzer/IStackTraceData';\nimport { IStorage } from '../../../interfaces/storages/IStorage';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNodes } from '../../../enums/container/CustomNodes';\nimport { ObfuscationEvents } from '../../../enums/ObfuscationEvents';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { RandomGeneratorUtils } from '../../../utils/RandomGeneratorUtils';\nimport { Utils } from '../../../utils/Utils';\n\n@injectable()\nexport class StringArrayCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {TObfuscationEvent}\n     */\n    protected appendEvent: TObfuscationEvent = ObfuscationEvents.AfterObfuscation;\n\n    /**\n     * @type {Map<CustomNodes, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes: Map <CustomNodes, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @type {IObfuscationEventEmitter}\n     */\n    private readonly obfuscationEventEmitter: IObfuscationEventEmitter;\n\n    /**\n     * @type {IStorage <string>}\n     */\n    @initializable()\n    private stringArrayStorage: IStorage <string>;\n\n    /**\n     * @param customNodeFactory\n     * @param obfuscationEventEmitter\n     * @param stringArrayStorage\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.IObfuscationEventEmitter) obfuscationEventEmitter: IObfuscationEventEmitter,\n        @inject(ServiceIdentifiers.TStringArrayStorage) stringArrayStorage: IStorage<string>,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.customNodeFactory = customNodeFactory;\n        this.obfuscationEventEmitter = obfuscationEventEmitter;\n        this.stringArrayStorage = stringArrayStorage;\n    }\n\n    /**\n     * @param blockScopeNode\n     * @param stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockStatement, stackTraceData: IStackTraceData[]): void {\n        if (!this.stringArrayStorage.getLength()) {\n            return;\n        }\n\n        // stringArrayNode append\n        this.appendCustomNodeIfExist(CustomNodes.StringArrayNode, (customNode: ICustomNode) => {\n            NodeAppender.prependNode(blockScopeNode, customNode.getNode());\n        });\n\n        // stringArrayCallsWrapper append\n        this.appendCustomNodeIfExist(CustomNodes.StringArrayCallsWrapper, (customNode: ICustomNode) => {\n            NodeAppender.insertNodeAtIndex(blockScopeNode, customNode.getNode(), 1);\n        });\n\n        // stringArrayRotateFunctionNode append\n        this.appendCustomNodeIfExist(CustomNodes.StringArrayRotateFunctionNode, (customNode: ICustomNode) => {\n            NodeAppender.insertNodeAtIndex(blockScopeNode, customNode.getNode(), 1);\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNodes, ICustomNode> ();\n\n        if (!this.options.stringArray) {\n            return;\n        }\n\n        const stringArrayNode: ICustomNode = this.customNodeFactory(CustomNodes.StringArrayNode);\n        const stringArrayCallsWrapper: ICustomNode = this.customNodeFactory(CustomNodes.StringArrayCallsWrapper);\n        const stringArrayRotateFunctionNode: ICustomNode = this.customNodeFactory(CustomNodes.StringArrayRotateFunctionNode);\n\n        const stringArrayStorageId: string = this.stringArrayStorage.getStorageId();\n\n        const stringArrayName: string = `_${Utils.hexadecimalPrefix}${stringArrayStorageId}`;\n        const stringArrayCallsWrapperName: string = `_${Utils.hexadecimalPrefix}${Utils.stringRotate(stringArrayStorageId, 1)}`;\n\n        let stringArrayRotateValue: number;\n\n        if (this.options.rotateStringArray) {\n            stringArrayRotateValue = RandomGeneratorUtils.getRandomInteger(100, 500);\n        } else {\n            stringArrayRotateValue = 0;\n        }\n\n        stringArrayNode.initialize(this.stringArrayStorage, stringArrayName, stringArrayRotateValue);\n        stringArrayCallsWrapper.initialize(this.stringArrayStorage, stringArrayName, stringArrayCallsWrapperName);\n        stringArrayRotateFunctionNode.initialize(this.stringArrayStorage, stringArrayName, stringArrayRotateValue);\n\n        this.customNodes.set(CustomNodes.StringArrayNode, stringArrayNode);\n        this.customNodes.set(CustomNodes.StringArrayCallsWrapper, stringArrayCallsWrapper);\n\n        if (this.options.rotateStringArray) {\n            this.customNodes.set(CustomNodes.StringArrayRotateFunctionNode, stringArrayRotateFunctionNode);\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup.ts","import { Utils } from '../utils/Utils';\n\nexport const VisitorDirection: any = Utils.strEnumify({\n    enter: 'enter',\n    leave: 'leave'\n});\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/enums/VisitorDirection.ts","import { decorate, injectable } from 'inversify';\n\nimport { IObfuscationEventEmitter } from '../interfaces/event-emitters/IObfuscationEventEmitter';\n\nimport { EventEmitter } from 'events';\n\ndecorate(injectable(), EventEmitter);\n\n@injectable()\nexport class ObfuscationEventEmitter extends EventEmitter implements IObfuscationEventEmitter {}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/event-emitters/ObfuscationEventEmitter.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TCustomNodeFactory } from '../../types/container/TCustomNodeFactory';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IVisitor } from '../../interfaces/IVisitor';\n\nimport { CustomNodes } from '../../enums/container/CustomNodes';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { Node } from '../../node/Node';\nimport { RandomGeneratorUtils } from '../../utils/RandomGeneratorUtils';\nimport { Utils } from '../../utils/Utils';\n\n@injectable()\nexport class BlockStatementControlFlowTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param customNodeFactory\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param blockStatementNode\n     * @return {boolean}\n     */\n    private static blockStatementHasProhibitedStatements (blockStatementNode: ESTree.BlockStatement): boolean {\n        return blockStatementNode.body.some((statement: ESTree.Statement) => {\n            const isBreakOrContinueStatement: boolean = Node.isBreakStatementNode(statement) || Node.isContinueStatementNode(statement);\n            const isVariableDeclarationWithLetOrConstKind: boolean = Node.isVariableDeclarationNode(statement) &&\n                (statement.kind === 'const' ||  statement.kind === 'let');\n\n            return Node.isFunctionDeclarationNode(statement) || isBreakOrContinueStatement || isVariableDeclarationWithLetOrConstKind;\n        });\n    }\n\n    /**\n     * @return {IVisitor}\n     */\n    public getVisitor (): IVisitor {\n        return {\n            leave: (node: ESTree.Node, parentNode: ESTree.Node) => {\n                if (Node.isBlockStatementNode(node)) {\n                    return this.transformNode(node, parentNode);\n                }\n            }\n        };\n    }\n\n    /**\n     * @param blockStatementNode\n     * @param parentNode\n     * @returns {ESTree.Node}\n     */\n    public transformNode (blockStatementNode: ESTree.BlockStatement, parentNode: ESTree.Node): ESTree.Node {\n        if (\n            RandomGeneratorUtils.getMathRandom() > this.options.controlFlowFlatteningThreshold ||\n            BlockStatementControlFlowTransformer.blockStatementHasProhibitedStatements(blockStatementNode)\n        ) {\n            return blockStatementNode;\n        }\n\n        const blockStatementBody: ESTree.Statement[] = blockStatementNode.body;\n\n        if (blockStatementBody.length <= 4) {\n            return blockStatementNode;\n        }\n\n        const originalKeys: number[] = Utils.arrayRange(blockStatementBody.length);\n        const shuffledKeys: number[] = Utils.arrayShuffle(originalKeys);\n        const originalKeysIndexesInShuffledArray: number[] = originalKeys.map((key: number) => shuffledKeys.indexOf(key));\n        const blockStatementControlFlowFlatteningCustomNode: ICustomNode = this.customNodeFactory(\n            CustomNodes.BlockStatementControlFlowFlatteningNode\n        );\n\n        blockStatementControlFlowFlatteningCustomNode.initialize(\n            blockStatementBody,\n            shuffledKeys,\n            originalKeysIndexesInShuffledArray\n        );\n\n        return blockStatementControlFlowFlatteningCustomNode.getNode()[0];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TControlFlowReplacerFactory } from '../../types/container/TControlFlowReplacerFactory';\nimport { TControlFlowStorageFactory } from '../../types/container/TControlFlowStorageFactory';\nimport { TCustomNodeFactory } from '../../types/container/TCustomNodeFactory';\nimport { TNodeWithBlockStatement } from '../../types/node/TNodeWithBlockStatement';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IStorage } from '../../interfaces/storages/IStorage';\nimport { IVisitor } from '../../interfaces/IVisitor';\n\nimport { CustomNodes } from '../../enums/container/CustomNodes';\nimport { NodeType } from '../../enums/NodeType';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { Node } from '../../node/Node';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { ControlFlowReplacers } from '../../enums/container/ControlFlowReplacers';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { RandomGeneratorUtils } from '../../utils/RandomGeneratorUtils';\n\n@injectable()\nexport class FunctionControlFlowTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Map <string, ControlFlowReplacers>}\n     */\n    private static readonly controlFlowReplacersMap: Map <string, ControlFlowReplacers> = new Map([\n        [NodeType.BinaryExpression, ControlFlowReplacers.BinaryExpressionControlFlowReplacer],\n        [NodeType.CallExpression, ControlFlowReplacers.CallExpressionControlFlowReplacer],\n        [NodeType.LogicalExpression, ControlFlowReplacers.LogicalExpressionControlFlowReplacer]\n    ]);\n\n    /**\n     * @type {number}\n     */\n    private static readonly hostNodeSearchMinDepth: number = 0;\n\n    /**\n     * @type {number}\n     */\n    private static readonly hostNodeSearchMaxDepth: number = 2;\n\n    /**\n     * @type {Map<ESTree.Node, IStorage<ICustomNode>>}\n     */\n    private readonly controlFlowData: Map <ESTree.Node, IStorage<ICustomNode>> = new Map();\n\n    /**\n     * @type {Set<ESTree.Function>}\n     */\n    private readonly visitedFunctionNodes: Set<ESTree.Function> = new Set();\n\n    /**\n     * @type {Set<TNodeWithBlockStatement>}\n     */\n    private readonly hostNodesWithControlFlowNode: Set<TNodeWithBlockStatement> = new Set();\n\n    /**\n     * @type {TControlFlowReplacerFactory}\n     */\n    private readonly controlFlowReplacerFactory: TControlFlowReplacerFactory;\n\n    /**\n     * @type {TControlFlowStorageFactory}\n     */\n    private readonly controlFlowStorageFactory: TControlFlowStorageFactory;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param controlFlowStorageFactory\n     * @param controlFlowReplacerFactory\n     * @param customNodeFactory\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__TControlFlowStorage) controlFlowStorageFactory: TControlFlowStorageFactory,\n        @inject(ServiceIdentifiers.Factory__IControlFlowReplacer) controlFlowReplacerFactory: TControlFlowReplacerFactory,\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.controlFlowStorageFactory = controlFlowStorageFactory;\n        this.controlFlowReplacerFactory = controlFlowReplacerFactory;\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param functionNodeBody\n     * @returns {TNodeWithBlockStatement}\n     */\n    private static getHostNode (functionNodeBody: ESTree.BlockStatement): TNodeWithBlockStatement {\n        const blockScopesOfNode: TNodeWithBlockStatement[] = NodeUtils.getBlockScopesOfNode(functionNodeBody);\n\n        if (blockScopesOfNode.length === 1) {\n            return functionNodeBody;\n        } else {\n            blockScopesOfNode.pop();\n        }\n\n        if (blockScopesOfNode.length > FunctionControlFlowTransformer.hostNodeSearchMinDepth) {\n            blockScopesOfNode.splice(0, FunctionControlFlowTransformer.hostNodeSearchMinDepth);\n        }\n\n        if (blockScopesOfNode.length > FunctionControlFlowTransformer.hostNodeSearchMaxDepth) {\n            blockScopesOfNode.length = FunctionControlFlowTransformer.hostNodeSearchMaxDepth;\n        }\n\n        return RandomGeneratorUtils.getRandomGenerator().pickone(blockScopesOfNode);\n    }\n\n    /**\n     * @return {IVisitor}\n     */\n    public getVisitor (): IVisitor {\n        return {\n            leave: (node: ESTree.Node, parentNode: ESTree.Node) => {\n                if (\n                    Node.isFunctionDeclarationNode(node) ||\n                    Node.isFunctionExpressionNode(node) ||\n                    Node.isArrowFunctionExpressionNode(node)\n                ) {\n                    return this.transformNode(node, parentNode);\n                }\n            }\n        };\n    }\n\n    /**\n     * @param functionNode\n     * @param parentNode\n     * @returns {ESTree.Function}\n     */\n    public transformNode (functionNode: ESTree.Function, parentNode: ESTree.Node): ESTree.Function {\n        this.visitedFunctionNodes.add(functionNode);\n\n        if (!Node.isBlockStatementNode(functionNode.body)) {\n            return functionNode;\n        }\n\n        const hostNode: TNodeWithBlockStatement = FunctionControlFlowTransformer.getHostNode(functionNode.body);\n        const controlFlowStorage: IStorage<ICustomNode> = this.getControlFlowStorage(hostNode);\n\n        this.controlFlowData.set(hostNode, controlFlowStorage);\n        this.transformFunctionBody(functionNode.body, controlFlowStorage);\n\n        if (!controlFlowStorage.getLength()) {\n            return functionNode;\n        }\n\n        const controlFlowStorageCustomNode: ICustomNode = this.customNodeFactory(CustomNodes.ControlFlowStorageNode);\n\n        controlFlowStorageCustomNode.initialize(controlFlowStorage);\n        NodeAppender.prependNode(hostNode, controlFlowStorageCustomNode.getNode());\n        this.hostNodesWithControlFlowNode.add(hostNode);\n\n        return functionNode;\n    }\n\n    /**\n     * @param hostNode\n     * @return {IStorage<ICustomNode>}\n     */\n    private getControlFlowStorage (hostNode: TNodeWithBlockStatement): IStorage<ICustomNode> {\n        const controlFlowStorage: IStorage <ICustomNode> = this.controlFlowStorageFactory();\n\n        if (this.controlFlowData.has(hostNode)) {\n            if (this.hostNodesWithControlFlowNode.has(hostNode)) {\n                hostNode.body.shift();\n            }\n\n            const hostControlFlowStorage: IStorage<ICustomNode> = <IStorage<ICustomNode>>this.controlFlowData.get(hostNode);\n\n            controlFlowStorage.mergeWith(hostControlFlowStorage, true);\n        }\n\n        return controlFlowStorage;\n    }\n\n    /**\n     * @param node\n     * @return {boolean}\n     */\n    private isVisitedFunctionNode (node: ESTree.Node): boolean {\n        return (\n            Node.isFunctionDeclarationNode(node) ||\n            Node.isFunctionExpressionNode(node) ||\n            Node.isArrowFunctionExpressionNode(node)\n        ) && this.visitedFunctionNodes.has(node);\n    }\n\n    /**\n     * @param functionNodeBody\n     * @param controlFlowStorage\n     */\n    private transformFunctionBody (functionNodeBody: ESTree.BlockStatement, controlFlowStorage: IStorage<ICustomNode>): void {\n        estraverse.replace(functionNodeBody, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (this.isVisitedFunctionNode(node)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (!FunctionControlFlowTransformer.controlFlowReplacersMap.has(node.type)) {\n                    return node;\n                }\n\n                if (RandomGeneratorUtils.getMathRandom() > this.options.controlFlowFlatteningThreshold) {\n                    return node;\n                }\n\n                const controlFlowReplacerName: ControlFlowReplacers = <ControlFlowReplacers>FunctionControlFlowTransformer\n                    .controlFlowReplacersMap.get(node.type);\n\n                return {\n                    ...this.controlFlowReplacerFactory(controlFlowReplacerName).replace(node, parentNode, controlFlowStorage),\n                    parentNode\n                };\n            }\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/control-flow-transformers/FunctionControlFlowTransformer.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TCustomNodeFactory } from '../../../types/container/TCustomNodeFactory';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IStorage } from '../../../interfaces/storages/IStorage';\n\nimport { CustomNodes } from '../../../enums/container/CustomNodes';\n\nimport { ExpressionWithOperatorControlFlowReplacer } from './ExpressionWithOperatorControlFlowReplacer';\n\n@injectable()\nexport class BinaryExpressionControlFlowReplacer extends ExpressionWithOperatorControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param customNodeFactory\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(customNodeFactory, options);\n    }\n\n    /**\n     * @param binaryExpressionNode\n     * @param parentNode\n     * @param controlFlowStorage\n     * @returns {ESTree.Node}\n     */\n    public replace (\n        binaryExpressionNode: ESTree.BinaryExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: IStorage <ICustomNode>\n    ): ESTree.Node {\n        const replacerId: string = binaryExpressionNode.operator;\n        const binaryExpressionFunctionCustomNode: ICustomNode = this.customNodeFactory(CustomNodes.BinaryExpressionFunctionNode);\n\n        binaryExpressionFunctionCustomNode.initialize(replacerId);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            binaryExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            BinaryExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            binaryExpressionNode.left,\n            binaryExpressionNode.right\n        );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TCustomNodeFactory } from '../../../types/container/TCustomNodeFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IStorage } from '../../../interfaces/storages/IStorage';\n\nimport { CustomNodes } from '../../../enums/container/CustomNodes';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { Node } from '../../../node/Node';\n\n@injectable()\nexport class CallExpressionControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param customNodeFactory\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(customNodeFactory, options);\n    }\n\n    /**\n     * @param callExpressionNode\n     * @param parentNode\n     * @param controlFlowStorage\n     * @returns {ESTree.Node}\n     */\n    public replace (\n        callExpressionNode: ESTree.CallExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: IStorage <ICustomNode>\n    ): ESTree.Node {\n        const callee: ESTree.Expression = <ESTree.Expression>callExpressionNode.callee;\n\n        if (!Node.isIdentifierNode(callee)) {\n            return callExpressionNode;\n        }\n\n        const replacerId: string = String(callExpressionNode.arguments.length);\n        const callExpressionFunctionCustomNode: ICustomNode = this.customNodeFactory(CustomNodes.CallExpressionFunctionNode);\n        const expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[] = callExpressionNode.arguments;\n\n        callExpressionFunctionCustomNode.initialize(expressionArguments);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            callExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            CallExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            callee,\n            expressionArguments\n        );\n    }\n\n    /**\n     * @param controlFlowStorageId\n     * @param storageKey\n     * @param callee\n     * @param expressionArguments\n     * @param arguments\n     * @returns {ESTree.Node}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string,\n        callee: ESTree.Expression,\n        expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.customNodeFactory(\n            CustomNodes.CallExpressionControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey, callee, expressionArguments);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !Node.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TCustomNodeFactory } from '../../../types/container/TCustomNodeFactory';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IStorage } from '../../../interfaces/storages/IStorage';\n\nimport { CustomNodes } from '../../../enums/container/CustomNodes';\n\nimport { ExpressionWithOperatorControlFlowReplacer } from './ExpressionWithOperatorControlFlowReplacer';\nimport { Node } from '../../../node/Node';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class LogicalExpressionControlFlowReplacer extends ExpressionWithOperatorControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param customNodeFactory\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(customNodeFactory, options);\n    }\n\n    /**\n     * @param logicalExpressionNode\n     * @param parentNode\n     * @param controlFlowStorage\n     * @returns {ESTree.Node}\n     */\n    public replace (\n        logicalExpressionNode: ESTree.LogicalExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: IStorage <ICustomNode>\n    ): ESTree.Node {\n        if (this.checkForProhibitedExpressions(logicalExpressionNode.left, logicalExpressionNode.right)) {\n            return logicalExpressionNode;\n        }\n\n        const replacerId: string = logicalExpressionNode.operator;\n        const logicalExpressionFunctionCustomNode: ICustomNode = this.customNodeFactory(CustomNodes.LogicalExpressionFunctionNode);\n\n        logicalExpressionFunctionCustomNode.initialize(replacerId);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            logicalExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            LogicalExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            logicalExpressionNode.left,\n            logicalExpressionNode.right\n        );\n    }\n\n    /**\n     * @param leftExpression\n     * @param rightExpression\n     * @returns {boolean}\n     */\n    private checkForProhibitedExpressions (leftExpression: ESTree.Expression, rightExpression: ESTree.Expression): boolean {\n        return [leftExpression, rightExpression].some((expressionNode: ESTree.Node | ESTree.Expression): boolean => {\n            let nodeForCheck: ESTree.Node | ESTree.Expression;\n\n            if (!Node.isUnaryExpressionNode(expressionNode)) {\n                nodeForCheck = expressionNode;\n            } else {\n                nodeForCheck = NodeUtils.getUnaryExpressionArgumentNode(expressionNode);\n            }\n\n            return !Node.isLiteralNode(nodeForCheck) &&\n                !Node.isIdentifierNode(nodeForCheck) &&\n                !Node.isObjectExpressionNode(nodeForCheck) &&\n                !Node.isExpressionStatementNode(nodeForCheck);\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IVisitor } from '../../interfaces/IVisitor';\n\nimport { NodeType } from '../../enums/NodeType';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { Node } from '../../node/Node';\n\n@injectable()\nexport class MemberExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @return {IVisitor}\n     */\n    public getVisitor (): IVisitor {\n        return {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node) => {\n                if (Node.isMemberExpressionNode(node)) {\n                    return this.transformNode(node, parentNode);\n                }\n            }\n        };\n    }\n\n    /**\n     * replaces:\n     *     object.identifier = 1;\n     *\n     * on:\n     *     object['identifier'] = 1;\n     *\n     * and skip:\n     *     object[identifier] = 1;\n     *\n     * Literal node will be obfuscated by LiteralTransformer\n     *\n     * @param memberExpressionNode\n     * @param parentNode\n     * @returns {ESTree.Node}\n     */\n    public transformNode (memberExpressionNode: ESTree.MemberExpression, parentNode: ESTree.Node): ESTree.Node {\n        if (Node.isIdentifierNode(memberExpressionNode.property)) {\n            if (memberExpressionNode.computed) {\n                return memberExpressionNode;\n            }\n\n            memberExpressionNode.computed = true;\n            memberExpressionNode.property = {\n                type: NodeType.Literal,\n                value: memberExpressionNode.property.name,\n                raw: `'${memberExpressionNode.property.name}'`\n            };\n        }\n\n        return memberExpressionNode;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/converting-transformers/MemberExpressionTransformer.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IVisitor } from '../../interfaces/IVisitor';\n\nimport { NodeType } from '../../enums/NodeType';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { Node } from '../../node/Node';\n\n/**\n * replaces:\n *     foo () { //... };\n *\n * on:\n *     ['foo'] { //... };\n *\n * Literal node will be obfuscated by LiteralTransformer\n */\n@injectable()\nexport class MethodDefinitionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string[]}\n     */\n    private static readonly ignoredNames: string[] = ['constructor'];\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @return {IVisitor}\n     */\n    public getVisitor (): IVisitor {\n        return {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node) => {\n                if (Node.isMethodDefinitionNode(node)) {\n                    return this.transformNode(node, parentNode);\n                }\n            }\n        };\n    }\n\n    /**\n     * replaces:\n     *     object.identifier = 1;\n     *\n     * on:\n     *     object['identifier'] = 1;\n     *\n     * and skip:\n     *     object[identifier] = 1;\n     * Literal node will be obfuscated by LiteralTransformer\n     *\n     * @param methodDefinitionNode\n     * @param parentNode\n     * @returns {ESTree.Node}\n     */\n    public transformNode (methodDefinitionNode: ESTree.MethodDefinition, parentNode: ESTree.Node): ESTree.Node {\n        if (\n            Node.isIdentifierNode(methodDefinitionNode.key) &&\n            !MethodDefinitionTransformer.ignoredNames.includes(methodDefinitionNode.key.name) &&\n            methodDefinitionNode.computed === false\n        ) {\n            methodDefinitionNode.computed = true;\n            methodDefinitionNode.key = {\n                type: NodeType.Literal,\n                value: methodDefinitionNode.key.name,\n                raw: `'${methodDefinitionNode.key.name}'`\n            };\n        }\n\n        return methodDefinitionNode;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/converting-transformers/MethodDefinitionTransformer.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IVisitor } from '../../interfaces/IVisitor';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { Node } from '../../node/Node';\nimport { Nodes } from '../../node/Nodes';\n\n/**\n * Transform ES2015 template literals to ES5\n * Thanks to Babel for algorithm\n */\n@injectable()\nexport class TemplateLiteralTransformer extends AbstractNodeTransformer {\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param node\n     * @return {boolean}\n     */\n    private static isLiteralNodeWithStringValue (node: ESTree.Node): boolean {\n        return node && Node.isLiteralNode(node) && typeof node.value === 'string';\n    }\n\n    /**\n     * @return {IVisitor}\n     */\n    public getVisitor (): IVisitor {\n        return {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node) => {\n                if (Node.isTemplateLiteralNode(node)) {\n                    return this.transformNode(node, parentNode);\n                }\n            }\n        };\n    }\n\n    /**\n     * @param templateLiteralNode\n     * @param parentNode\n     * @returns {ESTree.Node}\n     */\n    public transformNode (templateLiteralNode: ESTree.TemplateLiteral, parentNode: ESTree.Node): ESTree.Node {\n        const templateLiteralExpressions: ESTree.Expression[] = templateLiteralNode.expressions;\n\n        let nodes: (ESTree.Literal | ESTree.Expression)[] = [];\n\n        templateLiteralNode.quasis.forEach((templateElement: ESTree.TemplateElement) => {\n            nodes.push(Nodes.getLiteralNode(templateElement.value.cooked));\n\n            const expression: ESTree.Expression | undefined = templateLiteralExpressions.shift();\n\n            if (!expression) {\n                return;\n            }\n\n            nodes.push(expression);\n        });\n\n        nodes = nodes.filter((node: ESTree.Literal | ESTree.Expression) => {\n            return !(Node.isLiteralNode(node) && node.value === '');\n        });\n\n        // since `+` is left-to-right associative\n        // ensure the first node is a string if first/second isn't\n        if (\n            !TemplateLiteralTransformer.isLiteralNodeWithStringValue(nodes[0]) &&\n            !TemplateLiteralTransformer.isLiteralNodeWithStringValue(nodes[1])\n        ) {\n            nodes.unshift(Nodes.getLiteralNode(''));\n        }\n\n        if (nodes.length > 1) {\n            let root: ESTree.BinaryExpression = Nodes.getBinaryExpressionNode(\n                '+',\n                <ESTree.Literal>nodes.shift(),\n                <ESTree.Expression>nodes.shift()\n            );\n\n            nodes.forEach((node: ESTree.Literal | ESTree.Expression) => {\n                root = Nodes.getBinaryExpressionNode('+', root, <ESTree.Literal | ESTree.Expression>node);\n            });\n\n            return root;\n        }\n\n        return nodes[0];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/converting-transformers/TemplateLiteralTransformer.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TObfuscationReplacerFactory } from '../../types/container/TObfuscationReplacerFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IObfuscationReplacerWithStorage } from '../../interfaces/node-transformers/IObfuscationReplacerWithStorage';\nimport { IVisitor } from '../../interfaces/IVisitor';\n\nimport { ObfuscationReplacers } from '../../enums/container/ObfuscationReplacers';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { Node } from '../../node/Node';\n\n/**\n * replaces:\n *     try {} catch (e) { console.log(e); };\n *\n * on:\n *     try {} catch (_0x12d45f) { console.log(_0x12d45f); };\n *\n */\n@injectable()\nexport class CatchClauseTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IObfuscationReplacerWithStorage}\n     */\n    private readonly identifierReplacer: IObfuscationReplacerWithStorage;\n\n    /**\n     * @param obfuscationReplacerFactory\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IObfuscationReplacer) obfuscationReplacerFactory: TObfuscationReplacerFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.identifierReplacer = <IObfuscationReplacerWithStorage>obfuscationReplacerFactory(ObfuscationReplacers.IdentifierReplacer);\n    }\n\n    /**\n     * @return {IVisitor}\n     */\n    public getVisitor (): IVisitor {\n        return {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node) => {\n                if (Node.isCatchClauseNode(node)) {\n                    return this.transformNode(node, parentNode);\n                }\n            }\n        };\n    }\n\n    /**\n     * @param catchClauseNode\n     * @param parentNode\n     * @returns {ESTree.Node}\n     */\n    public transformNode (catchClauseNode: ESTree.CatchClause, parentNode: ESTree.Node): ESTree.Node {\n        const nodeIdentifier: number = this.nodeIdentifier++;\n\n        this.storeCatchClauseParam(catchClauseNode, nodeIdentifier);\n        this.replaceCatchClauseParam(catchClauseNode, nodeIdentifier);\n\n        return catchClauseNode;\n    }\n\n    /**\n     * @param catchClauseNode\n     * @param nodeIdentifier\n     */\n    private storeCatchClauseParam (catchClauseNode: ESTree.CatchClause, nodeIdentifier: number): void {\n        if (Node.isIdentifierNode(catchClauseNode.param)) {\n            this.identifierReplacer.storeNames(catchClauseNode.param.name, nodeIdentifier);\n        }\n    }\n\n    /**\n     * @param catchClauseNode\n     * @param nodeIdentifier\n     */\n    private replaceCatchClauseParam (catchClauseNode: ESTree.CatchClause, nodeIdentifier: number): void {\n        estraverse.replace(catchClauseNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (Node.isReplaceableIdentifierNode(node, parentNode)) {\n                    const newNodeName: string = this.identifierReplacer.replace(node.name, nodeIdentifier);\n\n                    if (node.name !== newNodeName) {\n                        node.name = newNodeName;\n                        node.obfuscatedNode = true;\n                    }\n                }\n            }\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/obfuscating-transformers/CatchClauseTransformer.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeWithBlockStatement } from '../../types/node/TNodeWithBlockStatement';\nimport { TObfuscationReplacerFactory } from '../../types/container/TObfuscationReplacerFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IObfuscationReplacerWithStorage } from '../../interfaces/node-transformers/IObfuscationReplacerWithStorage';\nimport { IVisitor } from '../../interfaces/IVisitor';\n\nimport { ObfuscationReplacers } from '../../enums/container/ObfuscationReplacers';\nimport { NodeType } from '../../enums/NodeType';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { Node } from '../../node/Node';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * replaces:\n *     function foo () { //... };\n *     foo();\n *\n * on:\n *     function _0x12d45f () { //... };\n *     _0x12d45f();\n */\n@injectable()\nexport class FunctionDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IObfuscationReplacerWithStorage}\n     */\n    private readonly identifierReplacer: IObfuscationReplacerWithStorage;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: Map <ESTree.Node, ESTree.Identifier[]> = new Map();\n\n    /**\n     * @param obfuscationReplacerFactory\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IObfuscationReplacer) obfuscationReplacerFactory: TObfuscationReplacerFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.identifierReplacer = <IObfuscationReplacerWithStorage>obfuscationReplacerFactory(ObfuscationReplacers.IdentifierReplacer);\n    }\n\n    /**\n     * @return {IVisitor}\n     */\n    public getVisitor (): IVisitor {\n        return {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node) => {\n                if (Node.isFunctionDeclarationNode(node)) {\n                    return this.transformNode(node, parentNode);\n                }\n            }\n        };\n    }\n\n    /**\n     * @param functionDeclarationNode\n     * @param parentNode\n     * @returns {ESTree.Node}\n     */\n    public transformNode (functionDeclarationNode: ESTree.FunctionDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const nodeIdentifier: number = this.nodeIdentifier++;\n        const blockScopeOfFunctionDeclarationNode: TNodeWithBlockStatement = NodeUtils\n            .getBlockScopesOfNode(functionDeclarationNode)[0];\n\n        if (blockScopeOfFunctionDeclarationNode.type === NodeType.Program) {\n            return functionDeclarationNode;\n        }\n\n        this.storeFunctionName(functionDeclarationNode, nodeIdentifier);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(blockScopeOfFunctionDeclarationNode)) {\n            this.replaceScopeCachedIdentifiers(blockScopeOfFunctionDeclarationNode, nodeIdentifier);\n        } else {\n            this.replaceScopeIdentifiers(blockScopeOfFunctionDeclarationNode, nodeIdentifier);\n        }\n\n        return functionDeclarationNode;\n    }\n\n    /**\n     * @param functionDeclarationNode\n     * @param nodeIdentifier\n     */\n    private storeFunctionName (functionDeclarationNode: ESTree.FunctionDeclaration, nodeIdentifier: number): void {\n        this.identifierReplacer.storeNames(functionDeclarationNode.id.name, nodeIdentifier);\n    }\n\n    /**\n     * @param scopeNode\n     * @param nodeIdentifier\n     */\n    private replaceScopeCachedIdentifiers (scopeNode: ESTree.Node, nodeIdentifier: number): void {\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] = <ESTree.Identifier[]>this.replaceableIdentifiers.get(scopeNode);\n\n        cachedReplaceableIdentifiers.forEach((replaceableIdentifier: ESTree.Identifier) => {\n            replaceableIdentifier.name = this.identifierReplacer.replace(replaceableIdentifier.name, nodeIdentifier);\n        });\n    }\n\n    /**\n     * @param scopeNode\n     * @param nodeIdentifier\n     */\n    private replaceScopeIdentifiers (scopeNode: ESTree.Node, nodeIdentifier: number): void {\n        const storedReplaceableIdentifiers: ESTree.Identifier[] = [];\n\n        estraverse.replace(scopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (Node.isReplaceableIdentifierNode(node, parentNode)) {\n                    const newNodeName: string = this.identifierReplacer.replace(node.name, nodeIdentifier);\n\n                    if (node.name !== newNodeName) {\n                        node.name = newNodeName;\n                    } else {\n                        storedReplaceableIdentifiers.push(node);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(scopeNode, storedReplaceableIdentifiers);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/obfuscating-transformers/FunctionDeclarationTransformer.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TObfuscationReplacerFactory } from '../../types/container/TObfuscationReplacerFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IObfuscationReplacerWithStorage } from '../../interfaces/node-transformers/IObfuscationReplacerWithStorage';\nimport { IVisitor } from '../../interfaces/IVisitor';\n\nimport { ObfuscationReplacers } from '../../enums/container/ObfuscationReplacers';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { Node } from '../../node/Node';\n\n/**\n * replaces:\n *     function foo (argument1) { return argument1; };\n *\n * on:\n *     function foo (_0x12d45f) { return _0x12d45f; };\n *\n */\n@injectable()\nexport class FunctionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IObfuscationReplacerWithStorage}\n     */\n    private readonly identifierReplacer: IObfuscationReplacerWithStorage;\n\n    /**\n     * @param obfuscationReplacerFactory\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IObfuscationReplacer) obfuscationReplacerFactory: TObfuscationReplacerFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.identifierReplacer = <IObfuscationReplacerWithStorage>obfuscationReplacerFactory(ObfuscationReplacers.IdentifierReplacer);\n    }\n\n    /**\n     * @return {IVisitor}\n     */\n    public getVisitor (): IVisitor {\n        return {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node) => {\n                if (\n                    Node.isFunctionDeclarationNode(node) ||\n                    Node.isFunctionExpressionNode(node) ||\n                    Node.isArrowFunctionExpressionNode(node)\n                ) {\n                    return this.transformNode(node, parentNode);\n                }\n            }\n        };\n    }\n\n    /**\n     * @param functionNode\n     * @param parentNode\n     * @returns {ESTree.Node}\n     */\n    public transformNode (functionNode: ESTree.Function, parentNode: ESTree.Node): ESTree.Node {\n        const nodeIdentifier: number = this.nodeIdentifier++;\n\n        this.storeFunctionParams(functionNode, nodeIdentifier);\n        this.replaceFunctionParams(functionNode, nodeIdentifier);\n\n        return functionNode;\n    }\n\n    /**\n     * @param functionNode\n     * @param nodeIdentifier\n     */\n    private storeFunctionParams (functionNode: ESTree.Function, nodeIdentifier: number): void {\n        functionNode.params\n            .forEach((paramsNode: ESTree.Node) => {\n                if (Node.isObjectPatternNode(paramsNode)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                estraverse.traverse(paramsNode, {\n                    enter: (node: ESTree.Node): any => {\n                        if (Node.isAssignmentPatternNode(node) && Node.isIdentifierNode(node.left)) {\n                            this.identifierReplacer.storeNames(node.left.name, nodeIdentifier);\n\n                            return estraverse.VisitorOption.Skip;\n                        }\n\n                        if (Node.isIdentifierNode(node)) {\n                            this.identifierReplacer.storeNames(node.name, nodeIdentifier);\n                        }\n                    }\n                });\n            });\n    }\n\n    /**\n     * @param functionNode\n     * @param nodeIdentifier\n     */\n    private replaceFunctionParams (functionNode: ESTree.Function, nodeIdentifier: number): void {\n        const traverseVisitor: estraverse.Visitor = {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (Node.isReplaceableIdentifierNode(node, parentNode)) {\n                    const newNodeName: string = this.identifierReplacer.replace(node.name, nodeIdentifier);\n\n                    if (node.name !== newNodeName) {\n                        node.name = newNodeName;\n                        node.obfuscatedNode = true;\n                    }\n                }\n            }\n        };\n\n        functionNode.params.forEach((paramsNode: ESTree.Node) => estraverse.replace(paramsNode, traverseVisitor));\n\n        estraverse.replace(functionNode.body, traverseVisitor);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/obfuscating-transformers/FunctionTransformer.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TObfuscationReplacerFactory } from '../../types/container/TObfuscationReplacerFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IObfuscationReplacerWithStorage } from '../../interfaces/node-transformers/IObfuscationReplacerWithStorage';\nimport { IVisitor } from '../../interfaces/IVisitor';\n\nimport { ObfuscationReplacers } from '../../enums/container/ObfuscationReplacers';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { Node } from '../../node/Node';\n\n/**\n * replaces:\n *     label: {\n *          for (var i = 0; i < 1000; i++) {\n *              break label;\n *          }\n *     }\n *\n * on:\n *     _0x12d45f: {\n *          for (var i = 0; i < 1000; i++) {\n *              break _0x12d45f;\n *          }\n *     }\n *\n */\n@injectable()\nexport class LabeledStatementTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IObfuscationReplacerWithStorage}\n     */\n    private readonly identifierReplacer: IObfuscationReplacerWithStorage;\n\n    /**\n     * @param obfuscationReplacerFactory\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IObfuscationReplacer) obfuscationReplacerFactory: TObfuscationReplacerFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.identifierReplacer = <IObfuscationReplacerWithStorage>obfuscationReplacerFactory(ObfuscationReplacers.IdentifierReplacer);\n    }\n\n    /**\n     * @return {IVisitor}\n     */\n    public getVisitor (): IVisitor {\n        return {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node) => {\n                if (Node.isLabeledStatementNode(node)) {\n                    return this.transformNode(node, parentNode);\n                }\n            }\n        };\n    }\n\n    /**\n     * @param labeledStatementNode\n     * @param parentNode\n     * @returns {ESTree.Node}\n     */\n    public transformNode (labeledStatementNode: ESTree.LabeledStatement, parentNode: ESTree.Node): ESTree.Node {\n        const nodeIdentifier: number = this.nodeIdentifier++;\n\n        this.storeLabeledStatementName(labeledStatementNode, nodeIdentifier);\n        this.replaceLabeledStatementName(labeledStatementNode, nodeIdentifier);\n\n        return labeledStatementNode;\n    }\n\n    /**\n     * @param labeledStatementNode\n     * @param nodeIdentifier\n     */\n    private storeLabeledStatementName (labeledStatementNode: ESTree.LabeledStatement, nodeIdentifier: number): void {\n        this.identifierReplacer.storeNames(labeledStatementNode.label.name, nodeIdentifier);\n    }\n\n    /**\n     * @param labeledStatementNode\n     * @param nodeIdentifier\n     */\n    private replaceLabeledStatementName (labeledStatementNode: ESTree.LabeledStatement, nodeIdentifier: number): void {\n        estraverse.replace(labeledStatementNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (Node.isLabelIdentifierNode(node, parentNode)) {\n                    node.name = this.identifierReplacer.replace(node.name, nodeIdentifier);\n                }\n            }\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/obfuscating-transformers/LabeledStatementTransformer.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as escodegen from 'escodegen-wallaby';\nimport * as ESTree from 'estree';\n\nimport { TObfuscationReplacerFactory } from '../../types/container/TObfuscationReplacerFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IVisitor } from '../../interfaces/IVisitor';\n\nimport { ObfuscationReplacers } from '../../enums/container/ObfuscationReplacers';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { Node } from '../../node/Node';\n\n@injectable()\nexport class LiteralTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {TObfuscationReplacerFactory}\n     */\n    private readonly obfuscationReplacerFactory: TObfuscationReplacerFactory;\n\n    /**\n     * @param obfuscationReplacerFactory\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IObfuscationReplacer) obfuscationReplacerFactory: TObfuscationReplacerFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.obfuscationReplacerFactory = obfuscationReplacerFactory;\n    }\n\n    /**\n     * @return {IVisitor}\n     */\n    public getVisitor (): IVisitor {\n        return {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node) => {\n                if (Node.isLiteralNode(node)) {\n                    return this.transformNode(node, parentNode);\n                }\n            }\n        };\n    }\n\n    /**\n     * @param literalNode\n     * @param parentNode\n     * @returns {ESTree.Node}\n     */\n    public transformNode (literalNode: ESTree.Literal, parentNode: ESTree.Node): ESTree.Node {\n        if (Node.isPropertyNode(parentNode) && parentNode.key === literalNode) {\n            return literalNode;\n        }\n\n        let content: string;\n\n        switch (typeof literalNode.value) {\n            case 'boolean':\n                content = this.obfuscationReplacerFactory(ObfuscationReplacers.BooleanReplacer)\n                    .replace(<boolean>literalNode.value);\n\n                break;\n\n            case 'number':\n                content = this.obfuscationReplacerFactory(ObfuscationReplacers.NumberLiteralReplacer)\n                    .replace(<number>literalNode.value);\n\n                break;\n\n            case 'string':\n                content = this.obfuscationReplacerFactory(ObfuscationReplacers.StringLiteralReplacer)\n                    .replace(<string>literalNode.value);\n\n                break;\n\n            default:\n                return literalNode;\n        }\n\n        literalNode['x-verbatim-property'] = {\n            content : content,\n            precedence: escodegen.Precedence.Primary\n        };\n\n        return literalNode;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/obfuscating-transformers/LiteralTransformer.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as escodegen from 'escodegen-wallaby';\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IVisitor } from '../../interfaces/IVisitor';\n\nimport { NodeType } from '../../enums/NodeType';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { Node } from '../../node/Node';\nimport { Utils } from '../../utils/Utils';\n\n/**\n * replaces:\n *     var object = { 'PSEUDO': 1 };\n *\n * or:\n *     var object = { PSEUDO: 1 };\n *\n * on:\n *     var object = { '\\u0050\\u0053\\u0045\\u0055\\u0044\\u004f': 1 };\n */\n@injectable()\nexport class ObjectExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param node\n     * @returns {ESTree.Literal}\n     */\n    private static transformLiteralPropertyKey (node: ESTree.Literal): ESTree.Literal {\n        if (typeof node.value === 'string' && !node['x-verbatim-property']) {\n            node['x-verbatim-property'] = {\n                content : `'${Utils.stringToUnicodeEscapeSequence(node.value)}'`,\n                precedence: escodegen.Precedence.Primary\n            };\n        }\n\n        return node;\n    }\n\n    /**\n     * @param node\n     * @returns {ESTree.Literal}\n     */\n    private static transformIdentifierPropertyKey (node: ESTree.Identifier): ESTree.Literal {\n        return {\n            type: NodeType.Literal,\n            value: node.name,\n            raw: `'${node.name}'`,\n            'x-verbatim-property': {\n                content : `'${Utils.stringToUnicodeEscapeSequence(node.name)}'`,\n                precedence: escodegen.Precedence.Primary\n            }\n        };\n    }\n\n    /**\n     * @return {IVisitor}\n     */\n    public getVisitor (): IVisitor {\n        return {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node) => {\n                if (Node.isObjectExpressionNode(node)) {\n                    return this.transformNode(node, parentNode);\n                }\n            }\n        };\n    }\n\n    /**\n     * @param objectExpressionNode\n     * @param parentNode\n     * @returns {ESTree.Node}\n     */\n    public transformNode (objectExpressionNode: ESTree.ObjectExpression, parentNode: ESTree.Node): ESTree.Node {\n        objectExpressionNode.properties\n            .forEach((property: ESTree.Property) => {\n                if (property.shorthand) {\n                    property.shorthand = false;\n                }\n\n                if (Node.isLiteralNode(property.key)) {\n                    property.key = ObjectExpressionTransformer.transformLiteralPropertyKey(property.key);\n                } else if (Node.isIdentifierNode(property.key)) {\n                    property.key = ObjectExpressionTransformer.transformIdentifierPropertyKey(property.key);\n                }\n            });\n\n        return objectExpressionNode;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/obfuscating-transformers/ObjectExpressionTransformer.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeWithBlockStatement } from '../../types/node/TNodeWithBlockStatement';\nimport { TObfuscationReplacerFactory } from '../../types/container/TObfuscationReplacerFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IObfuscationReplacerWithStorage } from '../../interfaces/node-transformers/IObfuscationReplacerWithStorage';\nimport { IVisitor } from '../../interfaces/IVisitor';\n\nimport { ObfuscationReplacers } from '../../enums/container/ObfuscationReplacers';\nimport { NodeType } from '../../enums/NodeType';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { Node } from '../../node/Node';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * replaces:\n *     var variable = 1;\n *     variable++;\n *\n * on:\n *     var _0x12d45f = 1;\n *     _0x12d45f++;\n *\n */\n@injectable()\nexport class VariableDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IObfuscationReplacerWithStorage}\n     */\n    private readonly identifierReplacer: IObfuscationReplacerWithStorage;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: Map <ESTree.Node, ESTree.Identifier[]> = new Map();\n\n    /**\n     * @param obfuscationReplacerFactory\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IObfuscationReplacer) obfuscationReplacerFactory: TObfuscationReplacerFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.identifierReplacer = <IObfuscationReplacerWithStorage>obfuscationReplacerFactory(ObfuscationReplacers.IdentifierReplacer);\n    }\n\n    /**\n     * @return {IVisitor}\n     */\n    public getVisitor (): IVisitor {\n        return {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node) => {\n                if (Node.isVariableDeclarationNode(node)) {\n                    return this.transformNode(node, parentNode);\n                }\n            }\n        };\n    }\n\n    /**\n     * @param variableDeclarationNode\n     * @param parentNode\n     * @returns {ESTree.Node}\n     */\n    public transformNode (variableDeclarationNode: ESTree.VariableDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const blockScopeOfVariableDeclarationNode: TNodeWithBlockStatement = NodeUtils\n            .getBlockScopesOfNode(variableDeclarationNode)[0];\n\n        if (blockScopeOfVariableDeclarationNode.type === NodeType.Program) {\n            return variableDeclarationNode;\n        }\n\n        const nodeIdentifier: number = this.nodeIdentifier++;\n        const scopeNode: ESTree.Node = variableDeclarationNode.kind === 'var'\n            ? blockScopeOfVariableDeclarationNode\n            : parentNode;\n\n        this.storeVariableNames(variableDeclarationNode, nodeIdentifier);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(scopeNode)) {\n            this.replaceScopeCachedIdentifiers(scopeNode, nodeIdentifier);\n        } else {\n            this.replaceScopeIdentifiers(scopeNode, nodeIdentifier);\n        }\n\n        return variableDeclarationNode;\n    }\n\n    /**\n     * @param variableDeclarationNode\n     * @param nodeIdentifier\n     */\n    private storeVariableNames (variableDeclarationNode: ESTree.VariableDeclaration, nodeIdentifier: number): void {\n        variableDeclarationNode.declarations\n            .forEach((declarationNode: ESTree.VariableDeclarator) => {\n                if (Node.isObjectPatternNode(declarationNode.id)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                NodeUtils.typedTraverse(declarationNode.id, NodeType.Identifier, {\n                    enter: (node: ESTree.Identifier) => this.identifierReplacer.storeNames(node.name, nodeIdentifier)\n                });\n            });\n    }\n\n    /**\n     * @param scopeNode\n     * @param nodeIdentifier\n     */\n    private replaceScopeCachedIdentifiers (scopeNode: ESTree.Node, nodeIdentifier: number): void {\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] = <ESTree.Identifier[]>this.replaceableIdentifiers.get(scopeNode);\n\n        cachedReplaceableIdentifiers.forEach((replaceableIdentifier: ESTree.Identifier) => {\n            replaceableIdentifier.name = this.identifierReplacer.replace(replaceableIdentifier.name, nodeIdentifier);\n        });\n    }\n\n    /**\n     * @param scopeNode\n     * @param nodeIdentifier\n     */\n    private replaceScopeIdentifiers (scopeNode: ESTree.Node, nodeIdentifier: number): void {\n        const storedReplaceableIdentifiers: ESTree.Identifier[] = [];\n\n        estraverse.replace(scopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (!node.obfuscatedNode && Node.isReplaceableIdentifierNode(node, parentNode)) {\n                    const newNodeName: string = this.identifierReplacer.replace(node.name, nodeIdentifier);\n\n                    if (node.name !== newNodeName) {\n                        node.name = newNodeName;\n                    } else {\n                        storedReplaceableIdentifiers.push(node);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(scopeNode, storedReplaceableIdentifiers);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/obfuscating-transformers/VariableDeclarationTransformer.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\nimport { JSFuck } from '../../../enums/JSFuck';\n\nimport { AbstractReplacer } from './AbstractReplacer';\n\n@injectable()\nexport class BooleanLiteralReplacer extends AbstractReplacer {\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param nodeValue\n     * @returns {string}\n     */\n    public replace (nodeValue: boolean): string {\n        return nodeValue ? JSFuck.True : JSFuck.False;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/obfuscating-transformers/replacers/BooleanLiteralReplacer.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { IObfuscationReplacerWithStorage } from '../../../interfaces/node-transformers/IObfuscationReplacerWithStorage';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\nimport { AbstractReplacer } from './AbstractReplacer';\nimport { RandomGeneratorUtils } from '../../../utils/RandomGeneratorUtils';\n\n@injectable()\nexport class IdentifierReplacer extends AbstractReplacer implements IObfuscationReplacerWithStorage {\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly namesMap: Map<string, string> = new Map();\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param nodeValue\n     * @param nodeIdentifier\n     * @returns {string}\n     */\n    public replace (nodeValue: string, nodeIdentifier: number): string {\n        const mapKey: string = `${nodeValue}-${String(nodeIdentifier)}`;\n\n        if (!this.namesMap.has(mapKey)) {\n            return nodeValue;\n        }\n\n        return <string>this.namesMap.get(mapKey);\n    }\n\n    /**\n     * Store all `nodeIdentifier`'s as keys in given `namesMap` with random names as value.\n     * Reserved names will be ignored.\n     *\n     * @param nodeName\n     * @param nodeIdentifier\n     */\n    public storeNames (nodeName: string, nodeIdentifier: number): void {\n        if (!this.isReservedName(nodeName)) {\n            this.namesMap.set(`${nodeName}-${String(nodeIdentifier)}`, RandomGeneratorUtils.getRandomVariableName(6));\n        }\n    }\n\n    /**\n     * @param name\n     * @returns {boolean}\n     */\n    private isReservedName (name: string): boolean {\n        return this.options.reservedNames\n            .some((reservedName: string) => {\n                return new RegExp(reservedName, 'g').exec(name) !== null;\n            });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/obfuscating-transformers/replacers/IdentifierReplacer.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\nimport { AbstractReplacer } from './AbstractReplacer';\nimport { Utils } from '../../../utils/Utils';\n\n@injectable()\nexport class NumberLiteralReplacer extends AbstractReplacer {\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly numberLiteralCache: Map <number, string> = new Map();\n\n    /**\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param nodeValue\n     * @returns {string}\n     */\n    public replace (nodeValue: number): string {\n        if (this.numberLiteralCache.has(nodeValue)) {\n            return <string>this.numberLiteralCache.get(nodeValue);\n        }\n\n        let result: string;\n\n        if (!Utils.isCeilNumber(nodeValue)) {\n            result = String(nodeValue);\n        } else {\n            result = `${Utils.hexadecimalPrefix}${Utils.decToHex(nodeValue)}`;\n        }\n\n        this.numberLiteralCache.set(nodeValue, result);\n\n        return result;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/obfuscating-transformers/replacers/NumberLiteralReplacer.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { ICustomNodeGroup } from '../../../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IEncodedValue } from '../../../interfaces/node-transformers/IEncodedValue';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IStorage } from '../../../interfaces/storages/IStorage';\n\nimport { StringArrayEncoding } from '../../../enums/StringArrayEncoding';\n\nimport { AbstractReplacer } from './AbstractReplacer';\nimport { CryptUtils } from '../../../utils/CryptUtils';\nimport { RandomGeneratorUtils } from '../../../utils/RandomGeneratorUtils';\nimport { Utils } from '../../../utils/Utils';\n\n@injectable()\nexport class StringLiteralReplacer extends AbstractReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly minimumLengthForStringArray: number = 3;\n\n    /**\n     * @type {IStorage<ICustomNodeGroup>}\n     */\n    private readonly customNodeGroupStorage: IStorage<ICustomNodeGroup>;\n\n    /**\n     * @type {string[]}\n     */\n    private readonly rc4Keys: string[];\n\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly stringLiteralCache: Map <string, string> = new Map();\n\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly stringLiteralHexadecimalIndexCache: Map <string, string> = new Map();\n\n    /**\n     * @type {IStorage<string>}\n     */\n    private readonly stringArrayStorage: IStorage<string>;\n\n    /**\n     * @param customNodeGroupStorage\n     * @param stringArrayStorage\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.TCustomNodeGroupStorage) customNodeGroupStorage: IStorage<ICustomNodeGroup>,\n        @inject(ServiceIdentifiers.TStringArrayStorage) stringArrayStorage: IStorage<string>,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.customNodeGroupStorage = customNodeGroupStorage;\n        this.stringArrayStorage = stringArrayStorage;\n\n        this.rc4Keys = RandomGeneratorUtils.getRandomGenerator()\n            .n(() => RandomGeneratorUtils.getRandomGenerator().string({length: 4}), 50);\n    }\n\n    /**\n     * @param nodeValue\n     * @returns {string}\n     */\n    public replace (nodeValue: string): string {\n        const usingStringArray: boolean = (\n            this.options.stringArray &&\n            nodeValue.length >= StringLiteralReplacer.minimumLengthForStringArray &&\n            RandomGeneratorUtils.getMathRandom() <= this.options.stringArrayThreshold\n        );\n        const cacheKey: string = `${nodeValue}-${String(usingStringArray)}`;\n\n        if (this.stringLiteralCache.has(cacheKey) && this.options.stringArrayEncoding !== StringArrayEncoding.rc4) {\n            return <string>this.stringLiteralCache.get(cacheKey);\n        }\n\n        let result: string;\n\n        if (usingStringArray) {\n            result = this.replaceStringLiteralWithStringArrayCall(nodeValue);\n        } else {\n            result = `'${Utils.stringToUnicodeEscapeSequence(nodeValue, !this.options.unicodeEscapeSequence)}'`;\n        }\n\n        this.stringLiteralCache.set(cacheKey, result);\n\n        return result;\n    }\n\n    /**\n     * @param value\n     * @return {string}\n     */\n    private getArrayHexadecimalIndex (value: string): string {\n        if (this.stringLiteralHexadecimalIndexCache.has(value)) {\n            return <string>this.stringLiteralHexadecimalIndexCache.get(value);\n        }\n\n        const stringArrayStorageLength: number = this.stringArrayStorage.getLength();\n        const hexadecimalIndex: string = `${Utils.hexadecimalPrefix}${Utils.decToHex(stringArrayStorageLength)}`;\n\n        this.stringArrayStorage.set(stringArrayStorageLength, value);\n        this.stringLiteralHexadecimalIndexCache.set(value, hexadecimalIndex);\n\n        return hexadecimalIndex;\n    }\n\n    /**\n     * @param value\n     * @returns {IEncodedValue}\n     */\n    private getEncodedValue (value: string): IEncodedValue {\n        let encodedValue: string,\n            key: string | undefined;\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.rc4:\n                key = RandomGeneratorUtils.getRandomGenerator().pickone(this.rc4Keys);\n                encodedValue = CryptUtils.btoa(CryptUtils.rc4(value, key));\n\n                break;\n\n            case StringArrayEncoding.base64:\n                encodedValue = CryptUtils.btoa(value);\n\n                break;\n\n            default:\n                encodedValue = value;\n        }\n\n        encodedValue = Utils.stringToUnicodeEscapeSequence(encodedValue, !this.options.unicodeEscapeSequence);\n\n        return { encodedValue, key };\n    }\n\n    /**\n     * @param value\n     * @returns {string}\n     */\n    private replaceStringLiteralWithStringArrayCall (value: string): string {\n        const { encodedValue, key }: IEncodedValue = this.getEncodedValue(value);\n        const hexadecimalIndex: string = this.getArrayHexadecimalIndex(encodedValue);\n        const rotatedStringArrayStorageId: string = Utils.stringRotate(this.stringArrayStorage.getStorageId(), 1);\n        const stringArrayStorageCallsWrapperName: string = `_${Utils.hexadecimalPrefix}${rotatedStringArrayStorageId}`;\n\n        if (key) {\n            return `${stringArrayStorageCallsWrapperName}('${hexadecimalIndex}', '${Utils.stringToUnicodeEscapeSequence(key, !this.options.unicodeEscapeSequence)}')`;\n        }\n\n        return `${stringArrayStorageCallsWrapperName}('${hexadecimalIndex}')`;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/node-transformers/obfuscating-transformers/replacers/StringLiteralReplacer.ts","import { injectable } from 'inversify';\n\nimport {\nArrayUnique,\nIsBoolean,\nIsArray,\nIsIn,\nIsNumber,\nIsString,\nIsUrl,\nMin,\nMax,\nValidateIf,\nvalidateSync,\nValidationError,\nValidatorOptions\n} from 'class-validator';\n\nimport { TInputOptions } from '../types/options/TInputOptions';\n\nimport { IOptions } from '../interfaces/options/IOptions';\n\nimport { TSourceMapMode } from '../types/TSourceMapMode';\nimport { TStringArrayEncoding } from '../types/options/TStringArrayEncoding';\n\nimport { DEFAULT_PRESET } from './presets/Default';\n\nimport { OptionsNormalizer } from './OptionsNormalizer';\nimport { ValidationErrorsFormatter } from './ValidationErrorsFormatter';\n\n@injectable()\nexport class Options implements IOptions {\n    /**\n     * @type {ValidatorOptions}\n     */\n    private static validatorOptions: ValidatorOptions = {\n        validationError: {\n            target: false\n        }\n    };\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly compact: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly controlFlowFlattening: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsNumber()\n    @Min(0)\n    @Max(1)\n    public readonly controlFlowFlatteningThreshold: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtection: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtectionInterval: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly disableConsoleOutput: boolean;\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly domainLock: string[];\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly reservedNames: string[];\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly rotateStringArray: boolean;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    public readonly seed: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly selfDefending: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly sourceMap: boolean;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    @ValidateIf((options: IOptions) => Boolean(options.sourceMapBaseUrl))\n    @IsUrl({\n        require_protocol: true,\n        require_valid_protocol: true\n    })\n    public readonly sourceMapBaseUrl: string;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly sourceMapFileName: string;\n\n    /**\n     * @type {TSourceMapMode}\n     */\n    @IsIn(['inline', 'separate'])\n    public readonly sourceMapMode: TSourceMapMode;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly stringArray: boolean;\n\n    /**\n     * @type {TStringArrayEncoding}\n     */\n    @IsIn([true, false, 'base64', 'rc4'])\n    public readonly stringArrayEncoding: TStringArrayEncoding;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    @Min(0)\n    @Max(1)\n    public readonly stringArrayThreshold: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly unicodeEscapeSequence: boolean;\n\n    /**\n     * @param inputOptions\n     */\n    constructor (inputOptions: TInputOptions) {\n        Object.assign(this, DEFAULT_PRESET, inputOptions);\n\n        const errors: ValidationError[] = validateSync(this, Options.validatorOptions);\n\n        if (errors.length) {\n            throw new ReferenceError(`Validation failed. errors:\\n${ValidationErrorsFormatter.format(errors)}`);\n        }\n\n        Object.assign(this, OptionsNormalizer.normalizeOptions(this));\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/options/Options.ts","import { TInputOptions } from '../types/options/TInputOptions';\n\nimport { IOptions } from '../interfaces/options/IOptions';\n\nimport { TOptionsNormalizerRule } from '../types/options/TOptionsNormalizerRule';\n\nimport { Utils } from '../utils/Utils';\n\nexport class OptionsNormalizer {\n    /**\n     * @type {TInputOptions}\n     */\n    private static readonly DISABLED_CONTROL_FLOW_FLATTENING_OPTIONS: TInputOptions = {\n        controlFlowFlattening: false,\n        controlFlowFlatteningThreshold: 0\n    };\n\n    /**\n     * @type {TInputOptions}\n     */\n    private static readonly DISABLED_STRING_ARRAY_OPTIONS: TInputOptions = {\n        rotateStringArray: false,\n        stringArray: false,\n        stringArrayEncoding: false,\n        stringArrayThreshold: 0\n    };\n\n    /**\n     * @type {TInputOptions}\n     */\n    private static readonly SELF_DEFENDING_OPTIONS: TInputOptions = {\n        compact: true,\n        selfDefending: true\n    };\n\n    /**\n     * @type {TInputOptions}\n     */\n    private static readonly STRING_ARRAY_ENCODING_OPTIONS: TInputOptions = {\n        stringArrayEncoding: 'base64'\n    };\n\n    /**\n     * @type {TOptionsNormalizerRule[]}\n     */\n    private static readonly normalizerRules: TOptionsNormalizerRule[] = [\n        OptionsNormalizer.controlFlowFlatteningThresholdRule,\n        OptionsNormalizer.domainLockRule,\n        OptionsNormalizer.selfDefendingRule,\n        OptionsNormalizer.sourceMapBaseUrlRule,\n        OptionsNormalizer.sourceMapFileNameRule,\n        OptionsNormalizer.stringArrayRule,\n        OptionsNormalizer.stringArrayEncodingRule,\n        OptionsNormalizer.stringArrayThresholdRule,\n    ];\n\n    /**\n     * @param options\n     * @returns {IOptions}\n     */\n    public static normalizeOptions (options: IOptions): IOptions {\n        let normalizedOptions: IOptions = {\n            ...options\n        };\n\n        for (const normalizerRule of OptionsNormalizer.normalizerRules) {\n            normalizedOptions = normalizerRule(normalizedOptions);\n        }\n\n        return normalizedOptions;\n    }\n\n    /**\n     * @param options\n     * @returns {IOptions}\n     */\n    private static controlFlowFlatteningThresholdRule (options: IOptions): IOptions {\n        if (options.controlFlowFlatteningThreshold === 0) {\n            options = {\n                ...options,\n                ...OptionsNormalizer.DISABLED_CONTROL_FLOW_FLATTENING_OPTIONS\n            };\n        }\n\n        return options;\n    }\n\n    /**\n     * @param options\n     * @returns {IOptions}\n     */\n    private static domainLockRule (options: IOptions): IOptions {\n        if (options.domainLock.length) {\n            const normalizedDomains: string[] = [];\n\n            for (const domain of options.domainLock) {\n                normalizedDomains.push(Utils.extractDomainFromUrl(domain));\n            }\n\n            options = {\n                ...options,\n                domainLock: normalizedDomains\n            };\n        }\n\n        return options;\n    }\n\n    /**\n     * @param options\n     * @returns {IOptions}\n     */\n    private static selfDefendingRule (options: IOptions): IOptions {\n        if (options.selfDefending) {\n            options = {\n                ...options,\n                ...OptionsNormalizer.SELF_DEFENDING_OPTIONS\n            };\n        }\n\n        return options;\n    }\n\n    /**\n     * @param options\n     * @returns {IOptions}\n     */\n    private static sourceMapBaseUrlRule (options: IOptions): IOptions {\n        const { sourceMapBaseUrl }: { sourceMapBaseUrl: string } = options;\n\n        if (!options.sourceMapFileName) {\n            options = {\n                ...options,\n                sourceMapBaseUrl: ''\n            };\n\n            return options;\n        }\n\n        if (sourceMapBaseUrl && !sourceMapBaseUrl.endsWith('/')) {\n            options = {\n                ...options,\n                sourceMapBaseUrl: `${sourceMapBaseUrl}/`\n            };\n        }\n\n        return options;\n    }\n\n    /**\n     * @param options\n     * @returns {IOptions}\n     */\n    private static sourceMapFileNameRule (options: IOptions): IOptions {\n        let { sourceMapFileName }: { sourceMapFileName: string } = options;\n\n        if (sourceMapFileName) {\n            sourceMapFileName = sourceMapFileName\n                .replace(/^\\/+/, '')\n                .split('.')[0];\n\n            options = {\n                ...options,\n                sourceMapFileName: `${sourceMapFileName}.js.map`\n            };\n        }\n\n        return options;\n    }\n\n    /**\n     * @param options\n     * @returns {IOptions}\n     */\n    private static stringArrayRule (options: IOptions): IOptions {\n        if (!options.stringArray) {\n            options = {\n                ...options,\n                ...OptionsNormalizer.DISABLED_STRING_ARRAY_OPTIONS\n            };\n        }\n\n        return options;\n    }\n\n    /**\n     * @param options\n     * @returns {IOptions}\n     */\n    private static stringArrayEncodingRule (options: IOptions): IOptions {\n        if (options.stringArrayEncoding === true) {\n            options = {\n                ...options,\n                ...OptionsNormalizer.STRING_ARRAY_ENCODING_OPTIONS\n            };\n        }\n\n        return options;\n    }\n\n    /**\n     * @param options\n     * @returns {IOptions}\n     */\n    private static stringArrayThresholdRule (options: IOptions): IOptions {\n        if (options.stringArrayThreshold === 0) {\n            options = {\n                ...options,\n                ...OptionsNormalizer.DISABLED_STRING_ARRAY_OPTIONS\n            };\n        }\n\n        return options;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/options/OptionsNormalizer.ts","import { ValidationError } from 'class-validator';\n\nexport class ValidationErrorsFormatter {\n    /**\n     * @param validationErrors\n     * @returns {string}\n     */\n    public static format (validationErrors: ValidationError[]): string {\n        const errorsArray: string[] = [];\n\n        for (const error of validationErrors) {\n            errorsArray.push(ValidationErrorsFormatter.formatError(error));\n        }\n\n        return errorsArray.join('\\n');\n    }\n\n    /**\n     * @param validationError\n     * @returns {string}\n     */\n    private static formatError (validationError: ValidationError): string {\n        const constraints: {[type: string]: string} = validationError.constraints;\n\n        let errorString: string = `\\`${validationError.property}\\` errors:\\n`;\n\n        for (const constraint in constraints) {\n            if (!constraints.hasOwnProperty(constraint)) {\n                continue;\n            }\n\n            errorString += `    - ${constraints[constraint]}\\n`;\n        }\n\n        return errorString;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/options/ValidationErrorsFormatter.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TCalleeDataExtractorFactory } from '../types/container/TCalleeDataExtractorFactory';\n\nimport { ICalleeData } from '../interfaces/stack-trace-analyzer/ICalleeData';\nimport { ICalleeDataExtractor } from '../interfaces/stack-trace-analyzer/ICalleeDataExtractor';\nimport { IStackTraceAnalyzer } from '../interfaces/stack-trace-analyzer/IStackTraceAnalyzer';\nimport { IStackTraceData } from '../interfaces/stack-trace-analyzer/IStackTraceData';\n\nimport { CalleeDataExtractors } from '../enums/container/CalleeDataExtractors';\n\nimport { Node } from '../node/Node';\nimport { NodeUtils } from '../node/NodeUtils';\n\n/**\n * This class generates a data with code stack trace functions calls\n *\n * For example:\n *\n * function Foo () {\n *     var baz = function () {\n *\n *     }\n *\n *     baz();\n * }\n *\n * foo();\n *\n * Will generate a structure like:\n *\n * [\n *      {\n *          callee: FOO_FUNCTION_NODE\n *          name: 'Foo',\n *          trace: [\n *              {\n *                  callee: BAZ_FUNCTION_NODE,\n *                  name: 'baz,\n *                  trace: []\n *              }\n *          ]\n *      }\n * ]\n */\n@injectable()\nexport class StackTraceAnalyzer implements IStackTraceAnalyzer {\n    /**\n     * @type {CalleeDataExtractors[]}\n     */\n    private static readonly calleeDataExtractorsList: CalleeDataExtractors[] = [\n        CalleeDataExtractors.FunctionDeclarationCalleeDataExtractor,\n        CalleeDataExtractors.FunctionExpressionCalleeDataExtractor,\n        CalleeDataExtractors.ObjectExpressionCalleeDataExtractor\n    ];\n\n    /**\n     * @type {number}\n     */\n    private static readonly limitThresholdActivationLength: number = 25;\n\n    /**\n     * @type {number}\n     */\n    private static readonly limitThreshold: number = 0.002;\n\n    /**\n     * @type {(calleeDataExtractorName: CalleeDataExtractors) => ICalleeDataExtractor}\n     */\n    private calleeDataExtractorFactory: (calleeDataExtractorName: CalleeDataExtractors) => ICalleeDataExtractor;\n\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICalleeDataExtractor) calleeDataExtractorFactory: TCalleeDataExtractorFactory\n    ) {\n        this.calleeDataExtractorFactory = calleeDataExtractorFactory;\n    }\n\n    /**\n     * @param blockScopeBodyLength\n     * @returns {number}\n     */\n    public static getLimitIndex (blockScopeBodyLength: number): number {\n        const lastIndex: number = blockScopeBodyLength - 1;\n        const limitThresholdActivationIndex: number = StackTraceAnalyzer.limitThresholdActivationLength - 1;\n\n        let limitIndex: number = lastIndex;\n\n        if (lastIndex > limitThresholdActivationIndex) {\n            limitIndex = Math.round(\n                limitThresholdActivationIndex + (lastIndex * StackTraceAnalyzer.limitThreshold)\n            );\n\n            if (limitIndex > lastIndex) {\n                limitIndex = lastIndex;\n            }\n        }\n\n        return limitIndex;\n    }\n\n    /**\n     * @param blockScopeBody\n     * @returns {IStackTraceData[]}\n     */\n    public analyze (blockScopeBody: ESTree.Node[]): IStackTraceData[] {\n        return this.analyzeRecursive(blockScopeBody);\n    }\n\n    /**\n     * @param blockScopeBody\n     * @returns {IStackTraceData[]}\n     */\n    private analyzeRecursive (blockScopeBody: ESTree.Node[]): IStackTraceData[] {\n        const limitIndex: number = StackTraceAnalyzer.getLimitIndex(blockScopeBody.length);\n        const stackTraceData: IStackTraceData[] = [];\n        const blockScopeBodyLength: number = blockScopeBody.length;\n\n        for (let index: number = 0; index < blockScopeBodyLength; index++) {\n            if (index > limitIndex) {\n                break;\n            }\n\n            const blockScopeBodyNode: ESTree.Node = blockScopeBody[index];\n\n            estraverse.traverse(blockScopeBodyNode, {\n                enter: (node: ESTree.Node): any => {\n                    if (!Node.isCallExpressionNode(node)) {\n                        return;\n                    }\n\n                    if (blockScopeBodyNode.parentNode !== NodeUtils.getBlockScopesOfNode(node)[0]) {\n                        return estraverse.VisitorOption.Skip;\n                    }\n\n                    this.analyzeCallExpressionNode(stackTraceData, blockScopeBody, node);\n                }\n            });\n        }\n\n        return stackTraceData;\n    }\n\n    /**\n     * @param stackTraceData\n     * @param blockScopeBody\n     * @param callExpressionNode\n     * @returns {IStackTraceData[]}\n     */\n    private analyzeCallExpressionNode (\n        stackTraceData: IStackTraceData[],\n        blockScopeBody: ESTree.Node[],\n        callExpressionNode: ESTree.CallExpression\n    ): void {\n        StackTraceAnalyzer.calleeDataExtractorsList.forEach((calleeDataExtractorName: CalleeDataExtractors) => {\n            const calleeData: ICalleeData | null = this.calleeDataExtractorFactory(calleeDataExtractorName)\n                .extract(blockScopeBody, callExpressionNode.callee);\n\n            if (!calleeData) {\n                return;\n            }\n\n            stackTraceData.push({\n                ...calleeData,\n                stackTrace: this.analyzeRecursive(calleeData.callee.body)\n            });\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/stack-trace-analyzer/StackTraceAnalyzer.ts","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../interfaces/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { Node } from '../../node/Node';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class FunctionDeclarationCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param blockScopeBody\n     * @param callee\n     * @returns {ICalleeData|null}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier): ICalleeData|null {\n        let calleeBlockStatement: ESTree.BlockStatement|null = null;\n\n        if (Node.isIdentifierNode(callee)) {\n            calleeBlockStatement = this.getCalleeBlockStatement(\n                NodeUtils.getBlockScopesOfNode(blockScopeBody[0])[0],\n                callee.name\n            );\n        }\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: callee.name\n        };\n    }\n\n    /**\n     * @param targetNode\n     * @param name\n     * @returns {ESTree.BlockStatement|null}\n     */\n    private getCalleeBlockStatement (targetNode: ESTree.Node, name: string): ESTree.BlockStatement|null {\n        let calleeBlockStatement: ESTree.BlockStatement|null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node): any => {\n                if (Node.isFunctionDeclarationNode(node) && node.id.name === name) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/stack-trace-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor.ts","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../interfaces/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { Node } from '../../node/Node';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class FunctionExpressionCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param blockScopeBody\n     * @param callee\n     * @returns {ICalleeData|null}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier): ICalleeData|null {\n        let calleeBlockStatement: ESTree.BlockStatement|null = null;\n\n        if (Node.isIdentifierNode(callee)) {\n            calleeBlockStatement = this.getCalleeBlockStatement(\n                NodeUtils.getBlockScopesOfNode(blockScopeBody[0])[0],\n                callee.name\n            );\n        }\n\n        if (Node.isFunctionExpressionNode(callee)) {\n            calleeBlockStatement = callee.body;\n        }\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: callee.name || null\n        };\n    }\n\n    /**\n     * @param targetNode\n     * @param name\n     * @returns {ESTree.BlockStatement|null}\n     */\n    private getCalleeBlockStatement (targetNode: ESTree.Node, name: string): ESTree.BlockStatement|null {\n        let calleeBlockStatement: ESTree.BlockStatement|null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (\n                    Node.isFunctionExpressionNode(node) &&\n                    Node.isVariableDeclaratorNode(parentNode) &&\n                    Node.isIdentifierNode(parentNode.id) &&\n                    parentNode.id.name === name\n                ) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/stack-trace-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor.ts","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TObjectMembersCallsChain } from '../../types/stack-trace-analyzer/TObjectMembersCallsChain';\n\nimport { ICalleeData } from '../../interfaces/stack-trace-analyzer/ICalleeData';\n\nimport { Node } from '../../node/Node';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\n\n@injectable()\nexport class ObjectExpressionCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param blockScopeBody\n     * @param callee\n     * @returns {ICalleeData|null}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.MemberExpression): ICalleeData|null {\n        let calleeBlockStatement: ESTree.BlockStatement|null = null,\n            functionExpressionName: string|number|null = null;\n\n        if (Node.isMemberExpressionNode(callee)) {\n            const objectMembersCallsChain: TObjectMembersCallsChain = this.createObjectMembersCallsChain([], callee);\n\n            if (!objectMembersCallsChain.length) {\n                return null;\n            }\n\n            functionExpressionName = objectMembersCallsChain[objectMembersCallsChain.length - 1];\n            calleeBlockStatement = this.getCalleeBlockStatement(\n                NodeUtils.getBlockScopesOfNode(blockScopeBody[0])[0],\n                objectMembersCallsChain\n            );\n        }\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: functionExpressionName\n        };\n    }\n\n    /**\n     * Creates array with MemberExpression calls chain.\n     *\n     * Example: object.foo.bar(); // ['object', 'foo', 'bar']\n     *\n     * @param currentChain\n     * @param memberExpression\n     * @returns {TObjectMembersCallsChain}\n     */\n    private createObjectMembersCallsChain (\n        currentChain: TObjectMembersCallsChain,\n        memberExpression: ESTree.MemberExpression\n    ): TObjectMembersCallsChain {\n        // first step: processing memberExpression `property` property\n        if (Node.isIdentifierNode(memberExpression.property) && memberExpression.computed === false) {\n            currentChain.unshift(memberExpression.property.name);\n        } else if (\n            Node.isLiteralNode(memberExpression.property) &&\n            (\n                typeof memberExpression.property.value === 'string' ||\n                typeof memberExpression.property.value === 'number'\n            )\n        ) {\n            currentChain.unshift(memberExpression.property.value);\n        } else {\n            return currentChain;\n        }\n\n        // second step: processing memberExpression `object` property\n        if (Node.isMemberExpressionNode(memberExpression.object)) {\n            return this.createObjectMembersCallsChain(currentChain, memberExpression.object);\n        } else if (Node.isIdentifierNode(memberExpression.object)) {\n            currentChain.unshift(memberExpression.object.name);\n        }\n\n        return currentChain;\n    }\n\n    /**\n     * @param targetNode\n     * @param objectMembersCallsChain\n     * @returns {ESTree.BlockStatement|null}\n     */\n    private getCalleeBlockStatement (\n        targetNode: ESTree.Node,\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement|null {\n        const objectName: string|number|undefined = objectMembersCallsChain.shift();\n\n        if (!objectName) {\n            return null;\n        }\n\n        let calleeBlockStatement: ESTree.BlockStatement|null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (\n                    Node.isVariableDeclaratorNode(node) &&\n                    Node.isIdentifierNode(node.id) &&\n                    node.init &&\n                    Node.isObjectExpressionNode(node.init) &&\n                    node.id.name === objectName\n                ) {\n                    calleeBlockStatement = this.findCalleeBlockStatement(node.init.properties, objectMembersCallsChain);\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n\n    /**\n     * @param objectExpressionProperties\n     * @param objectMembersCallsChain\n     * @returns {ESTree.BlockStatement|null}\n     */\n    private findCalleeBlockStatement (\n        objectExpressionProperties: ESTree.Property[],\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement|null {\n        const nextItemInCallsChain: string|number|undefined = objectMembersCallsChain.shift();\n\n        if (!nextItemInCallsChain) {\n            return null;\n        }\n\n        for (const propertyNode of objectExpressionProperties) {\n            const isTargetPropertyNodeWithIdentifierKey: boolean =\n                Node.isIdentifierNode(propertyNode.key) && propertyNode.key.name === nextItemInCallsChain;\n            const isTargetPropertyNodeWithLiteralKey: boolean =\n                Node.isLiteralNode(propertyNode.key) &&\n                Boolean(propertyNode.key.value) &&\n                propertyNode.key.value === nextItemInCallsChain;\n\n            if (!isTargetPropertyNodeWithIdentifierKey && !isTargetPropertyNodeWithLiteralKey) {\n                continue;\n            }\n\n            if (Node.isObjectExpressionNode(propertyNode.value)) {\n                return this.findCalleeBlockStatement(propertyNode.value.properties, objectMembersCallsChain);\n            }\n\n            if (Node.isFunctionExpressionNode(propertyNode.value)) {\n                return propertyNode.value.body;\n            }\n        }\n\n        return null;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/stack-trace-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor.ts","import { injectable } from 'inversify';\n\nimport { IStorage } from '../interfaces/storages/IStorage';\n\nimport { initializable } from '../decorators/Initializable';\n\nimport { RandomGeneratorUtils } from '../utils/RandomGeneratorUtils';\n\n@injectable()\nexport abstract class ArrayStorage <T> implements IStorage <T> {\n    /**\n     * @type {T[]}\n     */\n    @initializable()\n    protected storage: T[];\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected storageId: string;\n\n    /**\n     * @type {number}\n     */\n    private storageLength: number = 0;\n\n    /**\n     * @param key\n     * @returns {T}\n     */\n    public get (key: number): T {\n        const value: T | undefined = this.storage[key];\n\n        if (!value) {\n            throw new Error(`No value found in array storage with key \\`${key}\\``);\n        }\n\n        return value;\n    }\n\n    /**\n     * @param value\n     * @returns {number | null}\n     */\n    public getKeyOf (value: T): number | null {\n        const key: number = this.storage.indexOf(value);\n\n        return key >= 0 ? key : null;\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getLength (): number {\n        return this.storageLength;\n    }\n\n    /**\n     * @returns {T[]}\n     */\n    public getStorage (): T[] {\n        return this.storage;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageId (): string {\n        return this.storageId;\n    }\n\n    /**\n     * @param args\n     */\n    public initialize (...args: any[]): void {\n        this.storage = [];\n        this.storageId = RandomGeneratorUtils.getRandomString(6);\n    }\n\n    /**\n     * @param storage\n     * @param mergeId\n     */\n    public mergeWith (storage: this, mergeId: boolean = false): void {\n        this.storage = [...this.storage, ...storage.getStorage()];\n\n        if (mergeId) {\n            this.storageId = storage.getStorageId();\n        }\n    }\n\n    /**\n     * @param key\n     * @param value\n     */\n    public set (key: number, value: T): void {\n        if (key === this.storageLength) {\n            this.storage.push(value);\n        } else {\n            this.storage.splice(key, 0, value);\n        }\n\n        this.storageLength++;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/storages/ArrayStorage.ts","import { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\n\nimport { MapStorage } from '../MapStorage';\n\nexport class ControlFlowStorage extends MapStorage <ICustomNode> {\n    constructor () {\n        super();\n\n        this.initialize();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/storages/control-flow/ControlFlowStorage.ts","import { injectable, inject } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TCustomNodeGroupFactory } from '../../types/container/TCustomNodeGroupFactory';\n\nimport { ICustomNodeGroup } from '../../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { CustomNodeGroups } from '../../enums/container/CustomNodeGroups';\n\nimport { MapStorage } from '../MapStorage';\nimport { RandomGeneratorUtils } from '../../utils/RandomGeneratorUtils';\n\n@injectable()\nexport class CustomNodeGroupStorage extends MapStorage <ICustomNodeGroup> {\n    /**\n     * @type {CustomNodeGroups[]}\n     */\n    private static readonly customNodeGroupsList: CustomNodeGroups[] = [\n        CustomNodeGroups.ConsoleOutputCustomNodeGroup,\n        CustomNodeGroups.DebugProtectionCustomNodeGroup,\n        CustomNodeGroups.DomainLockCustomNodeGroup,\n        CustomNodeGroups.SelfDefendingCustomNodeGroup,\n        CustomNodeGroups.StringArrayCustomNodeGroup\n    ];\n\n    /**\n     * @type {TCustomNodesFactoriesFactory}\n     */\n    private readonly customNodeGroupFactory: TCustomNodeGroupFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @param customNodeGroupFactory\n     * @param options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNodeGroup) customNodeGroupFactory: TCustomNodeGroupFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super();\n\n        this.customNodeGroupFactory = customNodeGroupFactory;\n        this.options = options;\n\n        this.initialize();\n    }\n\n    public initialize (): void {\n        this.storage = new Map <string, ICustomNodeGroup> ();\n        this.storageId = RandomGeneratorUtils.getRandomString(6);\n\n        CustomNodeGroupStorage.customNodeGroupsList.forEach((customNodeGroupName: CustomNodeGroups) => {\n            const customNodeGroup: ICustomNodeGroup = this.customNodeGroupFactory(\n                customNodeGroupName\n            );\n\n            if (!customNodeGroup) {\n                return;\n            }\n\n            this.storage.set(customNodeGroupName, customNodeGroup);\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/storages/custom-node-group/CustomNodeGroupStorage.ts","import { injectable } from 'inversify';\n\nimport { ArrayStorage } from '../ArrayStorage';\nimport { RandomGeneratorUtils } from '../../utils/RandomGeneratorUtils';\nimport { Utils } from '../../utils/Utils';\n\n@injectable()\nexport class StringArrayStorage extends ArrayStorage <string> {\n    constructor () {\n        super();\n\n        this.initialize();\n    }\n\n    /**\n     * @param args\n     */\n    public initialize (...args: any[]): void {\n        super.initialize(args);\n\n        this.storageId = RandomGeneratorUtils.getRandomString(4, RandomGeneratorUtils.randomGeneratorPoolHexadecimal);\n    }\n\n    /**\n     * @param rotationValue\n     */\n    public rotateArray (rotationValue: number): void {\n        this.storage = Utils.arrayRotate(this.storage, rotationValue);\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.storage.map((value: string) => {\n            return `'${value}'`;\n        }).toString();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/storages/string-array/StringArrayStorage.ts","/**\n * @returns {string}\n */\nexport function AtobTemplate (): string {\n    return `\n        (function () {\n            var getGlobal = Function('return (function () ' + '{}.constructor(\"return this\")()' + ');');\n\n            var object = getGlobal();\n            var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n            object.atob || (\n                object.atob = function(input) {\n                    var str = String(input).replace(/=+$/, '');\n                    for (\n                        var bc = 0, bs, buffer, idx = 0, output = '';\n                        buffer = str.charAt(idx++);\n                        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n                            bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n                    ) {\n                        buffer = chars.indexOf(buffer);\n                    }\n                return output;\n            });\n        })();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/templates/custom-nodes/AtobTemplate.ts","/**\n * @returns {string}\n */\nexport function Rc4Template (): string {\n    return `\n        var rc4 = function (str, key) {\n            var s = [], j = 0, x, res = '', newStr = '';\n           \n            str = atob(str);\n                \n            for (var k = 0, length = str.length; k < length; k++) {\n                newStr += '%' + ('00' + str.charCodeAt(k).toString(16)).slice(-2);\n            }\n        \n            str = decodeURIComponent(newStr);\n                    \t        \n\t        for (var i = 0; i < 256; i++) {\n                s[i] = i;\n            }\n \n            for (i = 0; i < 256; i++) {\n                j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n            }\n            \n            i = 0;\n            j = 0;\n            \n            for (var y = 0; y < str.length; y++) {\n                i = (i + 1) % 256;\n                j = (j + s[i]) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n                res += String.fromCharCode(str.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n            }\n                      \n            return res;\n        }\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/templates/custom-nodes/Rc4Template.ts","/**\n * @returns {string}\n */\nexport function SingleNodeCallControllerTemplate (): string {\n    return `\n        var {singleNodeCallControllerFunctionName} = (function(){\n            var firstCall = true;\n            \n            return function (context, fn){\t\n                var rfn = firstCall ? function(){\n                    if(fn){\n                        var res = fn.apply(context, arguments);\n                        fn = null;\n                        return res;\n                    }\n                } : function(){}\n                \n                firstCall = false;\n                \n                return rfn;\n            }\n        })();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/templates/custom-nodes/SingleNodeCallControllerTemplate.ts","/**\n * @returns {string}\n */\nexport function ConsoleOutputDisableExpressionTemplate (): string {\n    return `\n        var {consoleLogDisableFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            var getGlobal = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');');\n            \n            var func = function () {};\n            var that = getGlobal();\n                        \n            if (!that.console) {\n                that.console = (function (func){ \n                    var c = {}; \n                    \n                    c.log = func;\n                    c.warn = func; \n                    c.debug = func;\n                    c.info = func;\n                    c.error = func;\n                    c.exception = func;\n                    c.trace = func;\n                    \n                    return c; \n                })(func);\n            } else {\n                that.console.log = func;\n                that.console.warn = func; \n                that.console.debug = func;\n                that.console.info = func;\n                that.console.error = func;\n                that.console.exception = func;\n                that.console.trace = func;\n            }\n        });\n        \n        {consoleLogDisableFunctionName}();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/templates/custom-nodes/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate.ts","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionCallTemplate (): string {\n    return `{debugProtectionFunctionName}();`;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/templates/custom-nodes/debug-protection-nodes/debug-protection-function-call-node/DebufProtectionFunctionCallTemplate.ts","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionIntervalTemplate (): string {\n    return `\n        setInterval(function () {\n            {debugProtectionFunctionName}();\n        }, 4000);\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/templates/custom-nodes/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate.ts","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionTemplate (): string {\n    return `\n        var {debugProtectionFunctionName} = function () {\n            function debuggerProtection (counter) {\n                if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                    (function () {}.constructor('debugger')());\n                } else {\n                    (function () {}.constructor('debugger')());\n                }\n                \n                debuggerProtection(++counter);\n            }\n            \n            try {\n                debuggerProtection(0);\n            } catch (y) {}\n        };\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/templates/custom-nodes/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate.ts","/**\n * @returns {string}\n */\nexport function DomainLockNodeTemplate (): string {\n    return `\n        var {domainLockFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            var getGlobal = Function('return (function () ' + '{}.constructor(\"return this\")()' + ');');\n\n            var func = function () { \n                return {\n                    key: 'item',\n                    value: 'attribute',\n                    getAttribute: function () {\n                        getGlobal()['eval']('while(true){}')();\n                    }()\n                };\n            };\n                        \n            var regExp = new RegExp(\"[{diff}]\", \"g\");\n            var domains = \"{domains}\".replace(regExp, \"\").split(\";\");\n            var eval = [][\"forEach\"][\"constructor\"];\n            var windowObject = eval(\"return this\")();\n            var document;\n            var domain;\n                        \n            for (var d in windowObject) {\n                if (d.length == 8 && d.charCodeAt(7) == 116 && d.charCodeAt(5) == 101 && d.charCodeAt(3) == 117 && d.charCodeAt(0) == 100) {\n                    document = d;\n                \n                    break;\n                }\n            }\n\n            for (var d1 in windowObject[document]) {\n                if (d1.length == 6 && d1.charCodeAt(5) == 110 && d1.charCodeAt(0) == 100) {\n                    domain = d1;\n                    \n                    break;\n                }\n            }\n            \n            if ((!document && !domain) || (!windowObject[document] && !windowObject[document][domain])) {\n                return;\n            }\n            \n            var currentDomain = windowObject[document][domain];\n\n            var ok = false;\n                        \n            for (var i = 0; i < domains.length; i++) {\n                var domain = domains[i];\n                var position = currentDomain.length - domain.length;\n                var lastIndex = currentDomain.indexOf(domain, position);\n                var endsWith = lastIndex !== -1 && lastIndex === position;\n                \n                if (endsWith) {\n                    if (currentDomain.length == domain.length || domain.indexOf(\".\") === 0) {\n                        ok = true;\n                    }\n                    \n                    break;\n                }\n            }\n               \n            if (!ok) {\n                data;\n            } else {\n                return;\n            }\n            \n            func();\n        });\n\n        {domainLockFunctionName}();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/templates/custom-nodes/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate.ts","import { Utils } from '../../../../utils/Utils';\n\n/**\n * SelfDefendingTemplate. Enters code in infinity loop.\n * Notice, that second and third call to recursiveFunc1('indexOf') has cyrillic `` character instead latin\n *\n * @returns {string}\n */\nexport function SelfDefendingTemplate (): string {\n    return `\n        var {selfDefendingFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            var func1 = function(){return 'dev';},\n                func2 = function () {\n                    return 'window';\n                };\n                \n            var test1 = function () {\n                var regExp = new RegExp('${Utils.stringToUnicodeEscapeSequence(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`)}');\n                \n                return !regExp.test(func1.toString());\n            };\n            \n            var test2 = function () {\n                var regExp = new RegExp('${Utils.stringToUnicodeEscapeSequence(`(\\\\\\\\[x|u](\\\\w){2,4})+`)}');\n                \n                return regExp.test(func2.toString());\n            };\n            \n            var recursiveFunc1 = function (string) {\n                var i = ~-1 >> 1 + 255 % 0;\n                                \n                if (string.indexOf('i' === i)) {\n                    recursiveFunc2(string)\n                }\n            };\n            \n            var recursiveFunc2 = function (string) {\n                var i = ~-4 >> 1 + 255 % 0;\n                \n                if (string.indexOf((true+\"\")[3]) !== i) {\n                    recursiveFunc1(string)\n                }\n            };\n            \n            if (!test1()) {\n                if (!test2()) {\n                    recursiveFunc1('indxOf');\n                } else {\n                    recursiveFunc1('indexOf');\n                }\n            } else {\n                recursiveFunc1('indxOf');\n            }\n        })\n        \n        {selfDefendingFunctionName}();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/templates/custom-nodes/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate.ts","import { Utils } from '../../../../utils/Utils';\n\n/**\n * @returns {string}\n */\nexport function SelfDefendingTemplate (): string {\n    return `\n        var StatesClass = function (rc4Bytes) {\n            this.rc4Bytes = rc4Bytes;\n            this.states = [1, 0, 0];\n            this.newState = function(){return 'newState';};\n            this.firstState = '${Utils.stringToUnicodeEscapeSequence(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *`)}';\n            this.secondState = '${Utils.stringToUnicodeEscapeSequence(`['|\"].+['|\"];? *}`)}';\n        };\n        \n        StatesClass.prototype.checkState = function () {\n            var regExp = new RegExp(this.firstState + this.secondState);\n\n            return this.runState(regExp.test(this.newState.toString()) ? --this.states[1] : --this.states[0]);\n        };\n        \n        StatesClass.prototype.runState = function (stateResult) {\n            if (!Boolean(~stateResult)) {\n                return stateResult;\n            }\n            \n            return this.getState(this.rc4Bytes);\n        };\n\n        StatesClass.prototype.getState = function (rc4Bytes) {\n            for (var i = 0, len = this.states.length; i < len; i++) {\n                this.states.push(Math.round(Math.random()));\n                len = this.states.length;\n            }\n            \n            return rc4Bytes(this.states[0]);\n        };\n\n        new StatesClass({stringArrayCallsWrapperName}).checkState();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate.ts","/**\n * @returns {string}\n */\nexport function StringArrayBase64DecodeNodeTemplate (): string {\n    return `      \n        if ({stringArrayCallsWrapperName}.initialized === undefined) {\n            {atobPolyfill}\n            \n            {stringArrayCallsWrapperName}.base64DecodeUnicode = function (str) {\n                var string = atob(str);\n                var newStringChars = [];\n                \n                for (var i = 0, length = string.length; i < length; i++) {\n                    newStringChars += '%' + ('00' + string.charCodeAt(i).toString(16)).slice(-2);\n                }\n                \n                return decodeURIComponent(newStringChars);\n            };\n            \n            {stringArrayCallsWrapperName}.data = {};\n            \n            {stringArrayCallsWrapperName}.initialized = true;\n        }\n                  \n        var cachedValue = {stringArrayCallsWrapperName}.data[index];\n                        \n        if (cachedValue === undefined) {\n            {selfDefendingCode}\n            \n            value = {stringArrayCallsWrapperName}.base64DecodeUnicode(value);\n            {stringArrayCallsWrapperName}.data[index] = value;\n        } else {\n            value = cachedValue;\n        }  \n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate.ts","/**\n * @returns {string}\n */\nexport function StringArrayCallsWrapperTemplate (): string {\n    return `\n        var {stringArrayCallsWrapperName} = function (index, key) {\n            index = index - 0;\n            \n            var value = {stringArrayName}[index];\n            \n            {decodeNodeTemplate}\n        \n            return value;\n        };\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate.ts","/**\n * @returns {string}\n */\nexport function StringArrayRc4DecodeNodeTemplate (): string {\n    return `\n        if ({stringArrayCallsWrapperName}.initialized === undefined) {\n            {atobPolyfill}\n            \n            {rc4Polyfill}\n            {stringArrayCallsWrapperName}.rc4 = rc4;\n            \n            {stringArrayCallsWrapperName}.data = {};\n            \n            {stringArrayCallsWrapperName}.initialized = true;\n        }\n  \n        var cachedValue = {stringArrayCallsWrapperName}.data[index];\n\n        if (cachedValue === undefined) {\n            if ({stringArrayCallsWrapperName}.once === undefined) {\n                {selfDefendingCode}\n                \n                {stringArrayCallsWrapperName}.once = true;\n            }\n            \n            value = {stringArrayCallsWrapperName}.rc4(value, key);\n            {stringArrayCallsWrapperName}.data[index] = value;\n        } else {\n            value = cachedValue;\n        }\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate.ts","/**\n * @returns {string}\n */\nexport function StringArrayTemplate (): string {\n    return `\n        var {stringArrayName} = [{stringArray}];\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/templates/custom-nodes/string-array-nodes/string-array-node/StringArrayTemplate.ts","import { Utils } from '../../../../utils/Utils';\n\n/**\n * SelfDefendingTemplate. Enter code in infinity loop.\n *\n * @returns {string}\n */\nexport function SelfDefendingTemplate (): string {\n    return `\n        var selfDefendingFunc = function () {            \n            var object = {\n                data: {\n                    key: 'cookie',\n                    value: 'timeout'\n                },\n                setCookie: function (options, name, value, document) {\n                    document = document || {};\n                    \n                    var updatedCookie = name + \"=\" + value;\n\n                    var i = 0;\n                                                            \n                    for (var i = 0, len = options.length; i < len; i++) {                          \n                        var propName = options[i];\n                                     \n                        updatedCookie += \"; \" + propName;\n                        \n                        var propValue = options[propName];\n                        \n                        options.push(propValue);\n                        len = options.length;\n                                                                        \n                        if (propValue !== true) {\n                            updatedCookie += \"=\" + propValue;\n                        }\n                    }\n\n                    document['cookie'] = updatedCookie;\n                },\n                removeCookie: function(){return 'dev';},\n                getCookie: function (document, name) {    \n                    document = document || function (value) { return value };\n                    var matches = document(new RegExp(\n                        \"(?:^|; )\" + name.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, '\\\\$1') + \"=([^;]*)\"\n                    ));\n                    \n                    var func = function (param1, param2) {\n                        param1(++param2);\n                    };\n                    \n                    func({whileFunctionName}, {timesName});\n                                        \n                    return matches ? decodeURIComponent(matches[1]) : undefined;\n                }\n            };\n            \n            var test1 = function () {\n                var regExp = new RegExp('${Utils.stringToUnicodeEscapeSequence(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`)}');\n                \n                return regExp.test(object.removeCookie.toString());\n            };\n            \n            object['updateCookie'] = test1;\n            \n            var cookie = '';\n            var result = object['updateCookie']();\n                                    \n            if (!result) {\n                object['setCookie'](['*'], 'counter', 1);\n            } else if (result) {\n                cookie = object['getCookie'](null, 'counter');     \n            } else {\n                object['removeCookie']();\n            }\n        };\n        \n        selfDefendingFunc();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/templates/custom-nodes/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate.ts","/**\n * @returns {string}\n */\nexport function StringArrayRotateFunctionTemplate (): string {\n    return `\n        (function (array, {timesName}) {\n            var {whileFunctionName} = function (times) {\n                while (--times) {\n                    array['push'](array['shift']());\n                }\n            };\n            \n            {code}\n        })({stringArrayName}, 0x{stringArrayRotateValue});\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/templates/custom-nodes/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate.ts","module.exports = require(\"chance\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"chance\"\n// module id = 121\n// module chunks = 0","module.exports = require(\"class-validator\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"class-validator\"\n// module id = 122\n// module chunks = 0","module.exports = require(\"commander\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"commander\"\n// module id = 123\n// module chunks = 0","module.exports = require(\"events\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"events\"\n// module id = 124\n// module chunks = 0","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 125\n// module chunks = 0","module.exports = require(\"mkdirp\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"mkdirp\"\n// module id = 126\n// module chunks = 0","module.exports = require(\"reflect-metadata\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"reflect-metadata\"\n// module id = 127\n// module chunks = 0","\"use strict\";\n\nimport { JavaScriptObfuscator } from './src/JavaScriptObfuscator';\n\nmodule.exports = JavaScriptObfuscator;\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./index.ts"],"sourceRoot":""}